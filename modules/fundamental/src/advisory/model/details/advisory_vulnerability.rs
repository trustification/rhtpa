use crate::{vulnerability::model::VulnerabilityHead, Error};
use sea_orm::{ColumnTrait, ConnectionTrait, EntityTrait, LoaderTrait, QueryFilter};
use serde::{Deserialize, Serialize};
use trustify_common::memo::Memo;
use trustify_cvss::cvss3::severity::Severity;
use trustify_cvss::{cvss3::score::Score, cvss3::Cvss3Base};
use trustify_entity::{advisory, advisory_vulnerability, cvss3, vulnerability};
use utoipa::ToSchema;

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct AdvisoryVulnerabilityHead {
    #[serde(flatten)]
    pub head: VulnerabilityHead,

    /// The English-language word description of the severity of the given
    /// vulnerability, as asserted by the advisory, using the CVSS bucketing
    /// ranges.
    ///
    /// Critical: 9.0–10.0
    /// High: 7.0–8.9
    /// Medium: 4.0–6.9
    /// Low: 0.1–3.9
    /// None: 0
    pub severity: Severity,

    /// The average (arithmetic mean) score this advisory assigns to
    /// the particular vulnerability.
    pub score: f64,
}

impl AdvisoryVulnerabilityHead {
    pub async fn from_entity<C: ConnectionTrait>(
        advisory: &advisory::Model,
        vulnerability: &vulnerability::Model,
        tx: &C,
    ) -> Result<Self, Error> {
        let cvss3 = cvss3::Entity::find()
            .filter(cvss3::Column::AdvisoryId.eq(advisory.id))
            .filter(cvss3::Column::VulnerabilityId.eq(&vulnerability.id))
            .all(tx)
            .await?;

        let score = Score::from_iter(cvss3.iter().map(Cvss3Base::from));

        let advisory_vuln = advisory_vulnerability::Entity::find()
            .filter(advisory_vulnerability::Column::AdvisoryId.eq(advisory.id))
            .filter(advisory_vulnerability::Column::VulnerabilityId.eq(&vulnerability.id))
            .one(tx)
            .await?;

        if let Some(advisory_vuln) = advisory_vuln {
            let head = if vulnerability.title.is_some() {
                VulnerabilityHead::from_vulnerability_entity(vulnerability, Memo::NotProvided, tx)
                    .await?
            } else {
                VulnerabilityHead::from_advisory_vulnerability_entity(&advisory_vuln, vulnerability)
            };
            Ok(AdvisoryVulnerabilityHead {
                head,
                severity: score.severity(),
                score: score.value(),
            })
        } else {
            Err(Error::Data(
                "Missing join between advisory and vulnerability".to_string(),
            ))
        }
    }

    pub async fn from_entities<C: ConnectionTrait>(
        advisory: &advisory::Model,
        vulnerabilities: &[vulnerability::Model],
        tx: &C,
    ) -> Result<Vec<Self>, Error> {
        let cvss3s = vulnerabilities
            .load_many(
                cvss3::Entity::find().filter(cvss3::Column::AdvisoryId.eq(advisory.id)),
                tx,
            )
            .await?;

        let mut heads = Vec::new();

        for (vuln, cvss3) in vulnerabilities.iter().zip(cvss3s.iter()) {
            let score = Score::from_iter(cvss3.iter().map(Cvss3Base::from));

            let advisory_vuln = advisory_vulnerability::Entity::find()
                .filter(advisory_vulnerability::Column::AdvisoryId.eq(advisory.id))
                .filter(advisory_vulnerability::Column::VulnerabilityId.eq(&vuln.id))
                .one(tx)
                .await?;
            if let Some(advisory_vuln) = advisory_vuln {
                let head = if vuln.title.is_some() {
                    VulnerabilityHead::from_vulnerability_entity(vuln, Memo::NotProvided, tx)
                        .await?
                } else {
                    VulnerabilityHead::from_advisory_vulnerability_entity(&advisory_vuln, vuln)
                };
                heads.push(AdvisoryVulnerabilityHead {
                    head,
                    severity: score.severity(),
                    score: score.value(),
                });
            }
        }

        Ok(heads)
    }
}

/// Summary of information from this advisory regarding a single specific vulnerability.
#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct AdvisoryVulnerabilitySummary {
    #[serde(flatten)]
    pub head: AdvisoryVulnerabilityHead,

    /// All CVSS3 scores from the advisory for the given vulnerability.
    /// May include several, varying by minor version of the CVSS3 vector.
    #[schema(default, value_type = Vec<String>)]
    pub cvss3_scores: Vec<String>,
}

impl AdvisoryVulnerabilitySummary {
    pub async fn from_entities<C: ConnectionTrait>(
        advisory: &advisory::Model,
        vulnerabilities: &[vulnerability::Model],
        tx: &C,
    ) -> Result<Vec<Self>, Error> {
        let mut cvss3s = vulnerabilities
            .load_many(
                cvss3::Entity::find().filter(cvss3::Column::AdvisoryId.eq(advisory.id)),
                tx,
            )
            .await?;

        let mut summaries = Vec::new();

        for (vuln, mut cvss3) in vulnerabilities.iter().zip(cvss3s.drain(..)) {
            let cvss3_scores = cvss3
                .drain(..)
                .map(|e| Cvss3Base::from(e).to_string())
                .collect();

            summaries.push(AdvisoryVulnerabilitySummary {
                head: AdvisoryVulnerabilityHead::from_entity(advisory, vuln, tx).await?,
                cvss3_scores,
            });
        }

        Ok(summaries)
    }
}
