#[cfg(test)]
mod test;

use crate::{
    endpoints::Deprecation,
    vulnerability::{
        model::{VulnerabilityDetails, VulnerabilitySummary},
        service::VulnerabilityService,
    },
    Error,
    Error::Internal,
};
use actix_web::{delete, get, web, HttpResponse, Responder};
use sea_orm::TransactionTrait;
use trustify_auth::{authorizer::Require, DeleteVulnerability, ReadAdvisory};
use trustify_common::{
    db::{query::Query, Database},
    model::{Paginated, PaginatedResults},
};

pub fn configure(config: &mut utoipa_actix_web::service_config::ServiceConfig, db: Database) {
    let service = VulnerabilityService::new();
    config
        .app_data(web::Data::new(service))
        .app_data(web::Data::new(db))
        .service(all)
        .service(delete)
        .service(get);
}

#[utoipa::path(
    tag = "vulnerability",
    operation_id = "listVulnerabilities",
    params(
        Query,
        Paginated,
    ),
    responses(
        (status = 200, description = "Matching vulnerabilities", body = PaginatedResults<VulnerabilitySummary>),
    ),
)]
#[get("/v1/vulnerability")]
/// List vulnerabilities
pub async fn all(
    state: web::Data<VulnerabilityService>,
    db: web::Data<Database>,
    web::Query(search): web::Query<Query>,
    web::Query(paginated): web::Query<Paginated>,
    web::Query(Deprecation { deprecated }): web::Query<Deprecation>,
    _: Require<ReadAdvisory>,
) -> actix_web::Result<impl Responder> {
    Ok(HttpResponse::Ok().json(
        state
            .fetch_vulnerabilities(search, paginated, deprecated, db.as_ref())
            .await?,
    ))
}

#[utoipa::path(
    tag = "vulnerability",
    operation_id = "getVulnerability",
    params(
        ("id", Path, description = "ID of the vulnerability")
    ),
    responses(
        (status = 200, description = "Specified vulnerability", body = VulnerabilityDetails),
        (status = 404, description = "Specified vulnerability not found"),
    ),
)]
#[get("/v1/vulnerability/{id}")]
/// Retrieve vulnerability details
pub async fn get(
    state: web::Data<VulnerabilityService>,
    db: web::Data<Database>,
    id: web::Path<String>,
    web::Query(Deprecation { deprecated }): web::Query<Deprecation>,
    _: Require<ReadAdvisory>,
) -> actix_web::Result<impl Responder> {
    let vuln = state
        .fetch_vulnerability(&id, deprecated, db.as_ref())
        .await?;
    if let Some(vuln) = vuln {
        Ok(HttpResponse::Ok().json(vuln))
    } else {
        Ok(HttpResponse::NotFound().finish())
    }
}

#[utoipa::path(
    tag = "vulnerability",
    operation_id = "deleteVulnerability",
    params(
        ("id", Path, description = "ID of the vulnerability")
    ),
    responses(
        (status = 200, description = "Specified vulnerability", body = VulnerabilityDetails),
        (status = 404, description = "Specified vulnerability not found"),
    ),
)]
#[delete("/v1/vulnerability/{id}")]
/// Delete vulnerability
pub async fn delete(
    state: web::Data<VulnerabilityService>,
    db: web::Data<Database>,
    id: web::Path<String>,
    _: Require<DeleteVulnerability>,
) -> Result<impl Responder, Error> {
    let tx = db.begin().await?;

    let vuln = state
        // we ignore deprecated advisories, as we delete the vulnerability anyway.
        .fetch_vulnerability(
            &id,
            trustify_module_ingestor::common::Deprecation::Ignore,
            &tx,
        )
        .await?;

    if let Some(vuln) = vuln {
        let rows_affected = state
            .delete_vulnerability(&vuln.head.identifier, &tx)
            .await?;
        match rows_affected {
            0 => Ok(HttpResponse::NotFound().finish()),
            1 => {
                tx.commit().await?;
                Ok(HttpResponse::Ok().json(vuln))
            }
            _ => Err(Internal("Unexpected number of rows affected".into())),
        }
    } else {
        Ok(HttpResponse::NotFound().finish())
    }
}
