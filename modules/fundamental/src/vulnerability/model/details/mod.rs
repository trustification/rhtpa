mod vulnerability_advisory;

pub use vulnerability_advisory::*;

use crate::{vulnerability::model::VulnerabilityHead, Error};
use sea_orm::{ColumnTrait, EntityTrait, LoaderTrait, ModelTrait, QueryFilter};
use serde::{Deserialize, Serialize};
use trustify_common::{db::ConnectionOrTransaction, memo::Memo};
use trustify_cvss::cvss3::{score::Score, severity::Severity, Cvss3Base};
use trustify_entity::{advisory_vulnerability, cvss3, vulnerability};
use trustify_module_ingestor::common::{Deprecation, DeprecationForExt};
use utoipa::ToSchema;

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityDetails {
    #[serde(flatten)]
    pub head: VulnerabilityHead,

    /// Average (arithmetic mean) severity of the vulnerability aggregated from *all* related advisories.
    #[schema(required)]
    pub average_severity: Option<Severity>,

    /// Average (arithmetic mean) score of the vulnerability aggregated from *all* related advisories.
    #[schema(required)]
    pub average_score: Option<f64>,

    /// Advisories addressing this vulnerability, if any.
    pub advisories: Vec<VulnerabilityAdvisorySummary>,
}

impl VulnerabilityDetails {
    pub async fn from_advisory_vulnerabilities(
        vulnerability: &vulnerability::Model,
        advisory_vulnerabilities: &[advisory_vulnerability::Model],
        vuln_cvss3s: &[cvss3::Model],
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Self, Error> {
        let advisories = VulnerabilityAdvisorySummary::from_entities(
            vulnerability,
            advisory_vulnerabilities,
            vuln_cvss3s,
            tx,
        )
        .await?;

        let cvss3 = cvss3::Entity::find()
            .filter(trustify_entity::cvss3::Column::VulnerabilityId.eq(&vulnerability.id))
            .all(tx)
            .await?;

        let total_score = cvss3
            .iter()
            .map(|e| {
                let base = Cvss3Base::from(e.clone());
                base.score().value()
            })
            .reduce(|accum, e| accum + e);

        let average_score = total_score.map(|total| Score::new(total / cvss3.len() as f64));

        Ok(VulnerabilityDetails {
            head: VulnerabilityHead {
                normative: true,
                identifier: vulnerability.id.clone(),
                title: None,
                description: None,
                reserved: None,
                published: None,
                modified: None,
                withdrawn: None,
                discovered: None,
                released: None,
                cwes: Vec::default(),
            },
            average_severity: average_score.map(|score| score.severity()),
            average_score: average_score.map(|score| score.value()),
            advisories,
        })
    }

    pub async fn from_entity(
        vulnerability: &vulnerability::Model,
        deprecation: Deprecation,
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Self, Error> {
        let advisory_vulnerabilities = vulnerability
            .find_related(advisory_vulnerability::Entity)
            .with_deprecation_related(deprecation)
            .all(tx)
            .await?;

        let cvss3 = cvss3::Entity::find()
            .filter(cvss3::Column::VulnerabilityId.eq(&vulnerability.id))
            .all(tx)
            .await?;

        let advisories = VulnerabilityAdvisorySummary::from_entities(
            vulnerability,
            &advisory_vulnerabilities,
            &cvss3,
            tx,
        )
        .await?;

        let total_score = cvss3
            .iter()
            .map(|e| {
                let base = Cvss3Base::from(e.clone());
                base.score().value()
            })
            .reduce(|accum, e| accum + e);

        let average_score = total_score.map(|total| Score::new(total / cvss3.len() as f64));

        Ok(VulnerabilityDetails {
            head: VulnerabilityHead::from_vulnerability_entity(
                vulnerability,
                Memo::NotProvided,
                tx,
            )
            .await?,
            average_severity: average_score.map(|score| score.severity()),
            average_score: average_score.map(|score| score.value()),
            advisories,
        })
    }

    pub async fn from_entities(
        vulnerabilities: &[vulnerability::Model],
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Vec<Self>, Error> {
        let advisory_vulnerabilities = vulnerabilities
            .load_many(advisory_vulnerability::Entity::find(), tx)
            .await?;

        let mut details = Vec::new();

        for (vulnerability, advisory_vulnerabilities) in
            vulnerabilities.iter().zip(advisory_vulnerabilities.iter())
        {
            let cvss3 = cvss3::Entity::find()
                .filter(cvss3::Column::VulnerabilityId.eq(&vulnerability.id))
                .all(tx)
                .await?;

            let total_score = cvss3
                .iter()
                .map(|e| {
                    let base = Cvss3Base::from(e.clone());
                    base.score().value()
                })
                .reduce(|accum, e| accum + e);

            let average_score = total_score.map(|total| Score::new(total / cvss3.len() as f64));

            details.push(VulnerabilityDetails {
                head: VulnerabilityHead::from_vulnerability_entity(
                    vulnerability,
                    Memo::NotProvided,
                    tx,
                )
                .await?,
                average_severity: average_score.map(|score| score.severity()),
                average_score: average_score.map(|score| score.value()),
                advisories: VulnerabilityAdvisorySummary::from_entities(
                    vulnerability,
                    advisory_vulnerabilities,
                    &cvss3,
                    tx,
                )
                .await?,
            })
        }

        Ok(details)
    }
}
