use crate::purl::model::details::purl::StatusContext;
use crate::purl::model::PurlHead;
use crate::sbom::model::SbomHead;
use crate::{advisory::model::AdvisoryHead, purl::model::BasePurlHead, Error};
use cpe::uri::OwnedUri;
use sea_orm::{
    ColumnTrait, DbErr, EntityTrait, FromQueryResult, IntoIdentity, LoaderTrait, ModelTrait,
    QueryFilter, QueryResult, QuerySelect, RelationTrait, Select,
};
use sea_query::{Asterisk, Expr, Func, IntoCondition, JoinType, SimpleExpr};
use serde::{Deserialize, Serialize};
use std::collections::hash_map::Entry;
use std::collections::{HashMap, HashSet};
use trustify_common::db::multi_model::{FromQueryResultMultiModel, SelectIntoMultiModel};
use trustify_common::db::VersionMatches;
use trustify_common::memo::Memo;
use trustify_common::{cpe::CpeCompare, db::ConnectionOrTransaction, purl::Purl};
use trustify_cvss::cvss3::severity::Severity;
use trustify_cvss::{cvss3::score::Score, cvss3::Cvss3Base};
use trustify_entity as entity;
use utoipa::ToSchema;
use uuid::Uuid;

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityAdvisoryHead {
    #[serde(flatten)]
    pub head: AdvisoryHead,
    #[schema(required)]
    pub severity: Option<Severity>,
    #[schema(required)]
    pub score: Option<f64>,
}

impl VulnerabilityAdvisoryHead {
    pub async fn from_entity(
        vulnerability: &entity::vulnerability::Model,
        advisory_vulnerability: &entity::advisory_vulnerability::Model,
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Self, Error> {
        let cvss3 = entity::cvss3::Entity::find()
            .filter(entity::cvss3::Column::AdvisoryId.eq(advisory_vulnerability.advisory_id))
            .filter(entity::cvss3::Column::VulnerabilityId.eq(&vulnerability.id))
            .all(tx)
            .await?;

        let total_score = cvss3
            .iter()
            .map(|e| {
                let base = Cvss3Base::from(e.clone());
                base.score().value()
            })
            .reduce(|accum, e| accum + e);

        let score = total_score.map(|score| Score::new(score / cvss3.len() as f64));

        if let Some(advisory) = &advisory_vulnerability
            .find_related(entity::advisory::Entity)
            .one(tx)
            .await?
        {
            Ok(VulnerabilityAdvisoryHead {
                head: AdvisoryHead::from_advisory(advisory, Memo::NotProvided, tx).await?,
                severity: score.map(|score| score.severity()),
                score: score.map(|score| score.value()),
            })
        } else {
            Err(Error::Data("Underlying advisory is missing".to_string()))
        }
    }
    pub async fn from_entities(
        vulnerability: &entity::vulnerability::Model,
        vuln_advisories: &[entity::advisory::Model],
        vuln_cvss3s: &[entity::cvss3::Model],
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Vec<Self>, Error> {
        let mut heads = Vec::new();

        let organizations = vuln_advisories
            .load_one(entity::organization::Entity, tx)
            .await?;

        for (advisory, issuer) in vuln_advisories.iter().zip(organizations.into_iter()) {
            // filter all vulnerability cvss3 to those that pertain to only this advisory.
            let advisory_cvss3s = vuln_cvss3s
                .iter()
                .filter(|e| e.vulnerability_id == vulnerability.id)
                .collect::<Vec<_>>();

            let total_score = advisory_cvss3s
                .iter()
                .map(|e| {
                    let base = Cvss3Base::from((*e).clone());
                    base.score().value()
                })
                .reduce(|accum, e| accum + e);

            let score = total_score.map(|score| Score::new(score / advisory_cvss3s.len() as f64));

            heads.push(VulnerabilityAdvisoryHead {
                head: AdvisoryHead::from_advisory(advisory, Memo::Provided(issuer), tx).await?,
                severity: score.map(|score| score.severity()),
                score: score.map(|score| score.value()),
            });
        }

        Ok(heads)
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityAdvisorySummary {
    #[serde(flatten)]
    pub head: VulnerabilityAdvisoryHead,

    /// CVSS3 scores from this advisory regarding the vulnerability.
    #[schema(default, value_type = Vec < String >)]
    pub cvss3_scores: Vec<String>,

    pub purls: HashMap<String, Vec<VulnerabilityAdvisoryStatus>>,

    /// SBOMs claimed by this advisory to be addressed by this vulnerability.
    pub sboms: Vec<VulnerabilitySbomStatus>,
}

impl VulnerabilityAdvisorySummary {
    pub async fn from_entities(
        vulnerability: &entity::vulnerability::Model,
        advisory_vulnerabilities: &[entity::advisory_vulnerability::Model],
        vuln_cvss3: &[entity::cvss3::Model],
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Vec<Self>, Error> {
        let purl_status_query = entity::purl_status::Entity::find()
            .left_join(entity::status::Entity)
            .filter(entity::purl_status::Column::VulnerabilityId.eq(&vulnerability.id))
            .left_join(entity::base_purl::Entity)
            .left_join(entity::version_range::Entity)
            .left_join(entity::cpe::Entity);

        let sbom_status_query = entity::sbom_package_purl_ref::Entity::find()
            .join(
                JoinType::LeftJoin,
                entity::sbom_package_purl_ref::Relation::Purl.def(),
            )
            .join(
                JoinType::LeftJoin,
                entity::qualified_purl::Relation::VersionedPurl.def(),
            )
            .join(
                JoinType::LeftJoin,
                entity::versioned_purl::Relation::BasePurl.def(),
            )
            .join(
                JoinType::LeftJoin,
                entity::base_purl::Relation::PurlStatus.def(),
            )
            .join(
                JoinType::Join,
                entity::purl_status::Relation::VersionRange.def(),
            )
            .join(JoinType::Join, entity::purl_status::Relation::Status.def())
            .join_as(
                JoinType::LeftJoin,
                entity::purl_status::Relation::ContextCpe.def(),
                "context_cpe".into_identity(),
            )
            .filter(entity::purl_status::Column::VulnerabilityId.eq(&vulnerability.id))
            .filter(SimpleExpr::FunctionCall(
                Func::cust(VersionMatches)
                    .arg(Expr::col((
                        entity::versioned_purl::Entity,
                        entity::versioned_purl::Column::Version,
                    )))
                    .arg(Expr::col((entity::version_range::Entity, Asterisk))),
            ))
            .join(
                JoinType::Join,
                entity::sbom_package_purl_ref::Relation::Sbom.def(),
            )
            .join(
                JoinType::LeftJoin,
                entity::sbom::Relation::Node
                    .def()
                    .on_condition(|left, right| {
                        Expr::col((right, entity::sbom_node::Column::SbomId))
                            .eq(Expr::col((left, entity::sbom::Column::SbomId)))
                            .into_condition()
                    }),
            )
            .join(JoinType::Join, entity::sbom_node::Relation::Package.def())
            .join(JoinType::Join, entity::sbom_package::Relation::Cpe.def())
            .join(
                JoinType::Join,
                entity::sbom_package_cpe_ref::Relation::Cpe.def(),
            )
            .select_only()
            .column_as(
                SimpleExpr::FunctionCall(
                    Func::cust("array_agg".into_identity())
                        .arg(SimpleExpr::Custom("DISTINCT status.slug".to_string())),
                ),
                "statuses",
            )
            .column(entity::purl_status::Column::AdvisoryId)
            .group_by(Expr::col((
                "context_cpe".into_identity(),
                "id".into_identity(),
            )))
            .group_by(entity::sbom::Column::SbomId)
            .group_by(entity::sbom_node::Column::SbomId)
            .group_by(entity::sbom_node::Column::NodeId)
            .group_by(entity::purl_status::Column::AdvisoryId)
            .group_by(entity::sbom_package::Column::SbomId)
            .group_by(entity::sbom_package::Column::NodeId)
            .group_by(entity::cpe::Column::Id);

        let vuln_purl_statuses = purl_status_query
            .try_into_multi_model::<PurlStatusCatcher>()?
            .all(tx)
            .await?;

        let vuln_sbom_statuses = sbom_status_query
            .try_into_multi_model::<SbomStatusCatcher>()?
            .all(tx)
            .await?;

        let mut summaries = Vec::new();

        for advisory_vulnerability in advisory_vulnerabilities {
            let cvss3_scores = vuln_cvss3
                .iter()
                .filter(|e| e.advisory_id == advisory_vulnerability.advisory_id)
                .map(|e| Cvss3Base::from(e.clone()).to_string())
                .collect();

            let purl_statuses = vuln_purl_statuses
                .iter()
                .filter(|e| e.purl_status.advisory_id == advisory_vulnerability.advisory_id);

            let sbom_statuses = vuln_sbom_statuses
                .iter()
                .filter(|e| e.advisory_id == advisory_vulnerability.advisory_id);

            summaries.push(VulnerabilityAdvisorySummary {
                head: VulnerabilityAdvisoryHead::from_entity(
                    vulnerability,
                    advisory_vulnerability,
                    tx,
                )
                .await?,
                cvss3_scores,
                purls: VulnerabilityAdvisoryStatus::from_models(purl_statuses, tx).await?,
                sboms: VulnerabilitySbomStatus::from_models(sbom_statuses, tx).await?,
            });
        }

        Ok(summaries)
    }
}

#[derive(Debug)]
struct PurlStatusCatcher {
    status: entity::status::Model,
    purl_status: entity::purl_status::Model,
    version_range: entity::version_range::Model,
    cpe: Option<entity::cpe::Model>,

    base_purl: entity::base_purl::Model,
}

impl FromQueryResult for PurlStatusCatcher {
    fn from_query_result(res: &QueryResult, _pre: &str) -> Result<Self, DbErr> {
        Ok(Self {
            status: Self::from_query_result_multi_model(res, "", entity::status::Entity)?,
            purl_status: Self::from_query_result_multi_model(res, "", entity::purl_status::Entity)?,
            version_range: Self::from_query_result_multi_model(
                res,
                "",
                entity::version_range::Entity,
            )?,
            cpe: Self::from_query_result_multi_model_optional(res, "", entity::cpe::Entity)?,
            base_purl: Self::from_query_result_multi_model(res, "", entity::base_purl::Entity)?,
        })
    }
}

impl FromQueryResultMultiModel for PurlStatusCatcher {
    fn try_into_multi_model<E: EntityTrait>(select: Select<E>) -> Result<Select<E>, DbErr> {
        select
            .try_model_columns(entity::status::Entity)?
            .try_model_columns(entity::purl_status::Entity)?
            .try_model_columns(entity::version_range::Entity)?
            .try_model_columns(entity::cpe::Entity)?
            .try_model_columns(entity::base_purl::Entity)
    }
}

impl PurlStatusCatcher {
    pub fn purl(&self) -> Purl {
        Purl {
            ty: self.base_purl.r#type.clone(),
            namespace: self.base_purl.namespace.clone(),
            name: self.base_purl.name.clone(),
            version: None,
            qualifiers: Default::default(),
        }
    }

    pub fn version(&self) -> String {
        match (
            &self.version_range.low_version,
            &self.version_range.high_version,
        ) {
            (Some(low), Some(high)) if low == high => low.clone(),
            (Some(low), Some(high)) => {
                let mut v = String::new();
                v.push(Self::open_delim(self.version_range.low_inclusive));
                v.push_str(low);
                v.push(',');
                v.push_str(high);
                v.push(Self::close_delim(self.version_range.high_inclusive));
                v
            }

            (Some(low), None) => {
                let mut v = String::new();
                v.push(Self::open_delim(self.version_range.low_inclusive));
                v.push_str(low);
                v.push(',');
                v.push(Self::close_delim(self.version_range.high_inclusive));
                v
            }
            (None, Some(high)) => {
                let mut v = String::new();
                v.push(Self::open_delim(self.version_range.low_inclusive));
                v.push(',');
                v.push_str(high);
                v.push(Self::close_delim(self.version_range.high_inclusive));
                v
            }
            (None, None) => "*".to_string(),
        }
    }

    fn open_delim(incl: Option<bool>) -> char {
        if let Some(incl) = incl {
            if incl {
                '['
            } else {
                '('
            }
        } else {
            '('
        }
    }

    fn close_delim(incl: Option<bool>) -> char {
        if let Some(incl) = incl {
            if incl {
                ']'
            } else {
                ')'
            }
        } else {
            ')'
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityAdvisoryStatus {
    pub base_purl: BasePurlHead,
    pub version: String,
    #[schema(required)]
    pub context: Option<StatusContext>,
}

impl VulnerabilityAdvisoryStatus {
    async fn from_models<'i, I: Iterator<Item = &'i PurlStatusCatcher>>(
        models: I,
        _tx: &ConnectionOrTransaction<'_>,
    ) -> Result<HashMap<String, Vec<Self>>, Error> {
        let mut statuses = HashMap::new();

        for each in models {
            let context = each.cpe.as_ref().and_then(|cpe| {
                let cpe: Result<OwnedUri, _> = cpe.try_into();
                cpe.ok().map(|cpe| StatusContext::Cpe(cpe.to_string()))
            });

            let status_entry = statuses.entry(each.status.slug.clone()).or_insert(vec![]);
            status_entry.push(VulnerabilityAdvisoryStatus {
                base_purl: BasePurlHead {
                    uuid: each.base_purl.id,
                    purl: each.purl(),
                },
                version: each.version(),
                context,
            });
        }

        Ok(statuses)
    }
}

#[derive(Debug)]
struct SbomStatusCatcher {
    //purl_status: entity::purl_status::Model,
    advisory_id: Uuid,
    context_cpe: Option<entity::cpe::Model>,
    sbom: entity::sbom::Model,
    sbom_package: entity::sbom_package::Model,
    sbom_node: entity::sbom_node::Model,
    statuses: Vec<String>,
    cpe: Option<entity::cpe::Model>,
}

impl FromQueryResult for SbomStatusCatcher {
    fn from_query_result(res: &QueryResult, _pre: &str) -> Result<Self, DbErr> {
        Ok(Self {
            advisory_id: res.try_get("", "advisory_id")?,
            context_cpe: Self::from_query_result_multi_model_optional(
                res,
                "context_cpe",
                entity::cpe::Entity,
            )?,
            sbom: Self::from_query_result_multi_model(res, "", entity::sbom::Entity)?,
            sbom_package: Self::from_query_result_multi_model(
                res,
                "",
                entity::sbom_package::Entity,
            )?,
            sbom_node: Self::from_query_result_multi_model(res, "", entity::sbom_node::Entity)?,
            statuses: res.try_get("", "statuses")?,
            cpe: Self::from_query_result_multi_model_optional(res, "", entity::cpe::Entity)?,
        })
    }
}

impl FromQueryResultMultiModel for SbomStatusCatcher {
    fn try_into_multi_model<E: EntityTrait>(select: Select<E>) -> Result<Select<E>, DbErr> {
        select
            .try_model_columns_from_alias(entity::cpe::Entity, "context_cpe")?
            .try_model_columns(entity::sbom::Entity)?
            .try_model_columns(entity::sbom_package::Entity)?
            .try_model_columns(entity::sbom_node::Entity)?
            .try_model_columns(entity::cpe::Entity)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize, ToSchema)]
pub struct VulnerabilitySbomStatus {
    #[serde(flatten)]
    pub head: SbomHead,

    pub version: Option<String>,
    #[serde(skip)]
    cpe: Option<OwnedUri>,

    pub status: HashSet<String>,
}

impl VulnerabilitySbomStatus {
    async fn from_models<'i, I>(
        sbom_purl_status: I,
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Vec<Self>, Error>
    where
        I: Iterator<Item = &'i SbomStatusCatcher> + Clone,
    {
        let mut sboms = HashMap::new();

        for status in sbom_purl_status.clone() {
            if let Entry::Vacant(e) = sboms.entry(&status.sbom.sbom_id) {
                let sbom_cpe = status.cpe.as_ref().and_then(|cpe| {
                    let sbom_cpe: Result<OwnedUri, _> = cpe.try_into();
                    sbom_cpe.ok()
                });

                e.insert(VulnerabilitySbomStatus {
                    head: SbomHead::from_entity(&status.sbom, Some(status.sbom_node.clone()), tx)
                        .await?,
                    version: status.sbom_package.version.clone(),
                    cpe: sbom_cpe,
                    status: Default::default(),
                });
            }
        }

        'status: for advisory_status in sbom_purl_status {
            if let Some(sbom_status) = sboms.get_mut(&advisory_status.sbom.sbom_id) {
                match (&advisory_status.context_cpe, &sbom_status.cpe) {
                    (Some(advisory_cpe), Some(sbom_cpe)) => {
                        let advisory_cpe: Result<OwnedUri, _> = advisory_cpe.try_into();

                        if let Ok(status_cpe) = advisory_cpe {
                            if status_cpe.is_superset(sbom_cpe) {
                                // the status context *is* applicable, fall through
                            } else {
                                // the status context *is not* applicable, skip
                                continue 'status;
                            }
                        } else {
                            // status_cpe is malformed, skip
                            continue 'status;
                        }
                    }
                    (Some(_), None) => {
                        // Advisory has context that does not apply to this sbom, skip
                        continue 'status;
                    }
                    (None, _) => {
                        // Advisory is not contextualized around a given CPE, fall through
                    }
                }

                sbom_status
                    .status
                    .extend(advisory_status.statuses.iter().cloned());
            }
        }

        Ok(sboms
            .drain()
            .filter_map(|(_, status)| {
                if status.status.is_empty() {
                    None
                } else {
                    Some(status)
                }
            })
            .collect())
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum SbomPackageStatus {
    Cpe(),
    Purl(PurlHead),
}
