use crate::{
    advisory::model::AdvisoryHead,
    purl::{model::details::purl::StatusContext, model::BasePurlHead, model::PurlHead},
    sbom::model::SbomHead,
    Error,
};
use ::cpe::cpe::Cpe;
use ::cpe::uri::OwnedUri;
use sea_orm::{
    ColumnTrait, ConnectionTrait, DbErr, EntityTrait, FromQueryResult, IntoIdentity, LoaderTrait,
    ModelTrait, PaginatorTrait, QueryFilter, QueryOrder, QueryResult, QuerySelect, RelationTrait,
    Select,
};
use sea_query::{Asterisk, Expr, Func, IntoCondition, JoinType, NullOrdering, SimpleExpr};
use serde::{Deserialize, Serialize};
use std::collections::{hash_map::Entry, HashMap, HashSet};
use trustify_common::{
    cpe::CpeCompare,
    db::{
        multi_model::{FromQueryResultMultiModel, SelectIntoMultiModel},
        VersionMatches,
    },
    memo::Memo,
    purl::Purl,
};
use trustify_cvss::cvss3::{score::Score, severity::Severity, Cvss3Base};
use trustify_entity::{
    self as entity, advisory, advisory_vulnerability, base_purl, cpe, cvss3, organization,
    purl_status, qualified_purl, sbom, sbom_node, sbom_package, sbom_package_cpe_ref,
    sbom_package_purl_ref, status, version_range, versioned_purl, vulnerability,
};
use utoipa::ToSchema;
use uuid::Uuid;

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityAdvisoryHead {
    #[serde(flatten)]
    pub head: AdvisoryHead,
    #[schema(required)]
    pub severity: Option<Severity>,
    #[schema(required)]
    pub score: Option<f64>,
}

impl VulnerabilityAdvisoryHead {
    pub async fn from_entity<C: ConnectionTrait>(
        vulnerability: &vulnerability::Model,
        advisory_vulnerability: &advisory_vulnerability::Model,
        tx: &C,
    ) -> Result<Self, Error> {
        let cvss3 = cvss3::Entity::find()
            .filter(cvss3::Column::AdvisoryId.eq(advisory_vulnerability.advisory_id))
            .filter(cvss3::Column::VulnerabilityId.eq(&vulnerability.id))
            .all(tx)
            .await?;

        let score = if cvss3.is_empty() {
            None
        } else {
            Some(Score::from_iter(cvss3.iter().map(Cvss3Base::from)))
        };

        if let Some(advisory) = &advisory_vulnerability
            .find_related(advisory::Entity)
            .one(tx)
            .await?
        {
            Ok(VulnerabilityAdvisoryHead {
                head: AdvisoryHead::from_advisory(advisory, Memo::NotProvided, tx).await?,
                severity: score.map(|score| score.severity()),
                score: score.map(|score| score.value()),
            })
        } else {
            Err(Error::Data("Underlying advisory is missing".to_string()))
        }
    }
    pub async fn from_entities<C: ConnectionTrait>(
        vulnerability: &vulnerability::Model,
        vuln_advisories: &[advisory::Model],
        vuln_cvss3s: &[cvss3::Model],
        tx: &C,
    ) -> Result<Vec<Self>, Error> {
        let mut heads = Vec::new();

        let organizations = vuln_advisories.load_one(organization::Entity, tx).await?;

        for (advisory, issuer) in vuln_advisories.iter().zip(organizations.into_iter()) {
            // filter all vulnerability cvss3 to those that pertain to only this advisory.
            let cvss3 = vuln_cvss3s
                .iter()
                .filter(|e| e.vulnerability_id == vulnerability.id)
                .collect::<Vec<_>>();

            let score = if cvss3.is_empty() {
                None
            } else {
                Some(Score::from_iter(cvss3.into_iter().map(Cvss3Base::from)))
            };

            heads.push(VulnerabilityAdvisoryHead {
                head: AdvisoryHead::from_advisory(advisory, Memo::Provided(issuer), tx).await?,
                severity: score.map(|score| score.severity()),
                score: score.map(|score| score.value()),
            });
        }

        Ok(heads)
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityAdvisorySummary {
    #[serde(flatten)]
    pub head: VulnerabilityAdvisoryHead,

    /// CVSS3 scores from this advisory regarding the vulnerability.
    #[schema(default, value_type = Vec < String >)]
    pub cvss3_scores: Vec<String>,

    pub purls: HashMap<String, Vec<VulnerabilityAdvisoryStatus>>,

    /// SBOMs claimed by this advisory to be addressed by this vulnerability.
    pub sboms: Vec<VulnerabilitySbomStatus>,

    /// The total number of vulnerabilities described by this advisory
    pub number_of_vulnerabilities: u64,
}

impl VulnerabilityAdvisorySummary {
    pub async fn from_entities<C: ConnectionTrait>(
        vulnerability: &vulnerability::Model,
        advisory_vulnerabilities: &[advisory_vulnerability::Model],
        vuln_cvss3: &[cvss3::Model],
        tx: &C,
    ) -> Result<Vec<Self>, Error> {
        let purl_status_query = purl_status::Entity::find()
            .left_join(status::Entity)
            .filter(purl_status::Column::VulnerabilityId.eq(&vulnerability.id))
            .left_join(base_purl::Entity)
            .left_join(version_range::Entity)
            .left_join(cpe::Entity);

        let sbom_status_query = sbom_package_purl_ref::Entity::find()
            .join(
                JoinType::LeftJoin,
                sbom_package_purl_ref::Relation::Purl.def(),
            )
            .join(
                JoinType::LeftJoin,
                qualified_purl::Relation::VersionedPurl.def(),
            )
            .join(JoinType::LeftJoin, versioned_purl::Relation::BasePurl.def())
            .join(JoinType::LeftJoin, base_purl::Relation::PurlStatus.def())
            .join(JoinType::Join, purl_status::Relation::VersionRange.def())
            .join(JoinType::Join, purl_status::Relation::Status.def())
            .join_as(
                JoinType::LeftJoin,
                purl_status::Relation::ContextCpe.def(),
                "context_cpe".into_identity(),
            )
            .filter(purl_status::Column::VulnerabilityId.eq(&vulnerability.id))
            .filter(SimpleExpr::FunctionCall(
                Func::cust(VersionMatches)
                    .arg(Expr::col((
                        versioned_purl::Entity,
                        versioned_purl::Column::Version,
                    )))
                    .arg(Expr::col((version_range::Entity, Asterisk))),
            ))
            .join(JoinType::Join, sbom_package_purl_ref::Relation::Sbom.def())
            .join(
                JoinType::LeftJoin,
                sbom::Relation::Node.def().on_condition(|left, right| {
                    Expr::col((right, sbom_node::Column::SbomId))
                        .eq(Expr::col((left, sbom::Column::SbomId)))
                        .into_condition()
                }),
            )
            .join(JoinType::Join, sbom_node::Relation::Package.def())
            .join(JoinType::Join, sbom_package::Relation::Cpe.def())
            .join(JoinType::Join, sbom_package_cpe_ref::Relation::Cpe.def())
            .select_only()
            .column_as(
                SimpleExpr::FunctionCall(
                    Func::cust("array_agg".into_identity())
                        .arg(SimpleExpr::Custom("DISTINCT status.slug".to_string())),
                ),
                "statuses",
            )
            .column(purl_status::Column::AdvisoryId)
            .group_by(Expr::col((
                "context_cpe".into_identity(),
                "id".into_identity(),
            )))
            .group_by(sbom::Column::SbomId)
            .group_by(sbom_node::Column::SbomId)
            .group_by(sbom_node::Column::NodeId)
            .group_by(purl_status::Column::AdvisoryId)
            .group_by(sbom_package::Column::SbomId)
            .group_by(sbom_package::Column::NodeId)
            .group_by(cpe::Column::Id);

        let product_status_query = entity::product_status::Entity::find()
            .join(
                JoinType::Join,
                entity::product_status::Relation::ContextCpe.def(),
            )
            .join(
                JoinType::Join,
                entity::product_status::Relation::Status.def(),
            )
            .join(
                JoinType::Join,
                entity::product_status::Relation::ProductVersionRange.def(),
            )
            .join(
                JoinType::Join,
                entity::product_version_range::Relation::VersionRange.def(),
            )
            .join(JoinType::Join, entity::cpe::Relation::Product.def())
            .join(
                JoinType::Join,
                entity::product::Relation::ProductVersion.def(),
            )
            .join(
                JoinType::LeftJoin,
                entity::product_version::Relation::Sbom.def(),
            )
            //.join(JoinType::LeftJoin, entity::sbom::Relation::Node.def())
            // TODO: The join below significantly speeds things up over the simple one above
            // Needs more investigation
            .join(
                JoinType::LeftJoin,
                entity::sbom::Relation::Node
                    .def()
                    .on_condition(|left, right| {
                        Expr::col((right, entity::sbom_node::Column::NodeId))
                            .eq(Expr::col((left, entity::sbom::Column::NodeId)))
                            .into_condition()
                    }),
            )
            .filter(entity::product_status::Column::VulnerabilityId.eq(&vulnerability.id))
            .filter(SimpleExpr::FunctionCall(
                Func::cust(VersionMatches)
                    .arg(Expr::col((
                        entity::product_version::Entity,
                        entity::product_version::Column::Version,
                    )))
                    .arg(Expr::col((entity::version_range::Entity, Asterisk))),
            ))
            .distinct_on([(entity::cpe::Entity, entity::cpe::Column::Id)])
            .order_by_desc(entity::cpe::Column::Id)
            .order_by_with_nulls(
                entity::product_version::Column::SbomId,
                sea_orm::Order::Desc,
                NullOrdering::Last,
            );

        let vuln_purl_statuses = purl_status_query
            .try_into_multi_model::<PurlStatusCatcher>()?
            .all(tx)
            .await?;

        let vuln_sbom_statuses = sbom_status_query
            .try_into_multi_model::<SbomStatusCatcher>()?
            .all(tx)
            .await?;

        let vuln_product_statuses = product_status_query
            .try_into_multi_model::<ProductStatusCatcher>()?
            .all(tx)
            .await?;

        let mut summaries = Vec::new();

        for advisory_vulnerability in advisory_vulnerabilities {
            let number_of_vulnerabilities = advisory_vulnerability
                .find_linked(advisory_vulnerability::AdvisoryVulnerabilityToAdvisoryVulnerabilities)
                .count(tx)
                .await?;

            let cvss3_scores = vuln_cvss3
                .iter()
                .filter(|e| e.advisory_id == advisory_vulnerability.advisory_id)
                .map(|e| Cvss3Base::from(e.clone()).to_string())
                .collect();

            let purl_statuses = vuln_purl_statuses
                .iter()
                .filter(|e| e.purl_status.advisory_id == advisory_vulnerability.advisory_id);

            let sbom_statuses = vuln_sbom_statuses
                .iter()
                .filter(|e| e.advisory_id == advisory_vulnerability.advisory_id);

            summaries.push(VulnerabilityAdvisorySummary {
                head: VulnerabilityAdvisoryHead::from_entity(
                    vulnerability,
                    advisory_vulnerability,
                    tx,
                )
                .await?,
                cvss3_scores,
                purls: VulnerabilityAdvisoryStatus::from_models(
                    purl_statuses,
                    vuln_product_statuses.iter(),
                )
                .await?,
                sboms: VulnerabilitySbomStatus::from_models(
                    sbom_statuses,
                    vuln_product_statuses.iter(),
                    tx,
                )
                .await?,
                number_of_vulnerabilities,
            });
        }

        Ok(summaries)
    }
}

#[derive(Debug)]
struct PurlStatusCatcher {
    status: status::Model,
    purl_status: purl_status::Model,
    version_range: version_range::Model,
    cpe: Option<cpe::Model>,

    base_purl: base_purl::Model,
}

impl FromQueryResult for PurlStatusCatcher {
    fn from_query_result(res: &QueryResult, _pre: &str) -> Result<Self, DbErr> {
        Ok(Self {
            status: Self::from_query_result_multi_model(res, "", status::Entity)?,
            purl_status: Self::from_query_result_multi_model(res, "", purl_status::Entity)?,
            version_range: Self::from_query_result_multi_model(res, "", version_range::Entity)?,
            cpe: Self::from_query_result_multi_model_optional(res, "", cpe::Entity)?,
            base_purl: Self::from_query_result_multi_model(res, "", base_purl::Entity)?,
        })
    }
}

impl FromQueryResultMultiModel for PurlStatusCatcher {
    fn try_into_multi_model<E: EntityTrait>(select: Select<E>) -> Result<Select<E>, DbErr> {
        select
            .try_model_columns(status::Entity)?
            .try_model_columns(purl_status::Entity)?
            .try_model_columns(version_range::Entity)?
            .try_model_columns(cpe::Entity)?
            .try_model_columns(base_purl::Entity)
    }
}

impl PurlStatusCatcher {
    pub fn purl(&self) -> Purl {
        Purl {
            ty: self.base_purl.r#type.clone(),
            namespace: self.base_purl.namespace.clone(),
            name: self.base_purl.name.clone(),
            version: None,
            qualifiers: Default::default(),
        }
    }

    pub fn version(&self) -> String {
        match (
            &self.version_range.low_version,
            &self.version_range.high_version,
        ) {
            (Some(low), Some(high)) if low == high => low.clone(),
            (Some(low), Some(high)) => {
                let mut v = String::new();
                v.push(Self::open_delim(self.version_range.low_inclusive));
                v.push_str(low);
                v.push(',');
                v.push_str(high);
                v.push(Self::close_delim(self.version_range.high_inclusive));
                v
            }

            (Some(low), None) => {
                let mut v = String::new();
                v.push(Self::open_delim(self.version_range.low_inclusive));
                v.push_str(low);
                v.push(',');
                v.push(Self::close_delim(self.version_range.high_inclusive));
                v
            }
            (None, Some(high)) => {
                let mut v = String::new();
                v.push(Self::open_delim(self.version_range.low_inclusive));
                v.push(',');
                v.push_str(high);
                v.push(Self::close_delim(self.version_range.high_inclusive));
                v
            }
            (None, None) => "*".to_string(),
        }
    }

    fn open_delim(incl: Option<bool>) -> char {
        if let Some(incl) = incl {
            if incl {
                '['
            } else {
                '('
            }
        } else {
            '('
        }
    }

    fn close_delim(incl: Option<bool>) -> char {
        if let Some(incl) = incl {
            if incl {
                ']'
            } else {
                ')'
            }
        } else {
            ')'
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityAdvisoryStatus {
    pub base_purl: BasePurlHead,
    pub version: String,
    #[schema(required)]
    pub context: Option<StatusContext>,
}

impl VulnerabilityAdvisoryStatus {
    async fn from_models<
        'i,
        'j,
        I: Iterator<Item = &'i PurlStatusCatcher>,
        J: Iterator<Item = &'j ProductStatusCatcher>,
    >(
        purls: I,
        products: J,
    ) -> Result<HashMap<String, Vec<Self>>, Error> {
        let mut statuses = HashMap::new();

        for each in purls {
            let context = each.cpe.as_ref().and_then(|cpe| {
                let cpe: Result<OwnedUri, _> = cpe.try_into();
                cpe.ok().map(|cpe| StatusContext::Cpe(cpe.to_string()))
            });

            let status_entry = statuses.entry(each.status.slug.clone()).or_insert(vec![]);
            status_entry.push(VulnerabilityAdvisoryStatus {
                base_purl: BasePurlHead {
                    uuid: each.base_purl.id,
                    purl: each.purl(),
                },
                version: each.version(),
                context,
            });
        }

        for product in products {
            if let Some(package) = &product.product_status.package {
                let status_entry = statuses
                    .entry(product.status.slug.clone())
                    .or_insert(vec![]);
                // TODO: If we have an SBOM in the result, we should try to locate the real purl
                // in that SBOM by the package name
                let purl = generic_purl(package);
                // This is creating a fake Purl that does not exists in the database
                // Maybe we should model this differently, e.g. introduce package instead of purl
                // in case there's no SBOM ot purl can't be found
                let base_purl = BasePurlHead {
                    uuid: Default::default(),
                    purl,
                };
                let context = StatusContext::Cpe(product.cpe.to_string());
                status_entry.push(VulnerabilityAdvisoryStatus {
                    base_purl,
                    version: "*".to_string(),
                    context: Some(context),
                });
            }
        }

        Ok(statuses)
    }
}

/// Parse purl from generic identifiers
fn generic_purl(name: &str) -> Purl {
    // try to extract at least name and optionally namespace
    // usually separate by /
    // e.g. io.quarkus/quarkus-vertx-http
    let parts = name.split('/').collect::<Vec<_>>();

    let (namespace, name) = if parts.len() >= 2 {
        (Some(parts[0]), parts[1])
    } else {
        (None, parts[0])
    };

    Purl {
        ty: "generic".to_string(),
        namespace: namespace.map(|s| s.to_string()),
        name: name.to_string(),
        version: None,
        qualifiers: Default::default(),
    }
}

#[derive(Debug)]
struct SbomStatusCatcher {
    advisory_id: Uuid,
    context_cpe: Option<cpe::Model>,
    sbom: sbom::Model,
    sbom_package: sbom_package::Model,
    sbom_node: sbom_node::Model,
    statuses: Vec<String>,
    cpe: Option<cpe::Model>,
}

impl FromQueryResult for SbomStatusCatcher {
    fn from_query_result(res: &QueryResult, _pre: &str) -> Result<Self, DbErr> {
        Ok(Self {
            advisory_id: res.try_get("", "advisory_id")?,
            context_cpe: Self::from_query_result_multi_model_optional(
                res,
                "context_cpe",
                cpe::Entity,
            )?,
            sbom: Self::from_query_result_multi_model(res, "", sbom::Entity)?,
            sbom_package: Self::from_query_result_multi_model(res, "", sbom_package::Entity)?,
            sbom_node: Self::from_query_result_multi_model(res, "", sbom_node::Entity)?,
            statuses: res.try_get("", "statuses")?,
            cpe: Self::from_query_result_multi_model_optional(res, "", cpe::Entity)?,
        })
    }
}

impl FromQueryResultMultiModel for SbomStatusCatcher {
    fn try_into_multi_model<E: EntityTrait>(select: Select<E>) -> Result<Select<E>, DbErr> {
        select
            .try_model_columns_from_alias(cpe::Entity, "context_cpe")?
            .try_model_columns(sbom::Entity)?
            .try_model_columns(sbom_package::Entity)?
            .try_model_columns(sbom_node::Entity)?
            .try_model_columns(cpe::Entity)
    }
}

#[derive(Debug)]
struct ProductStatusCatcher {
    product_status: entity::product_status::Model,
    cpe: entity::cpe::Model,
    status: entity::status::Model,
    product_version: Option<entity::product_version::Model>,
    sbom: Option<entity::sbom::Model>,
    sbom_node: Option<entity::sbom_node::Model>,
}

impl FromQueryResult for ProductStatusCatcher {
    fn from_query_result(res: &QueryResult, _pre: &str) -> Result<Self, DbErr> {
        Ok(Self {
            product_status: Self::from_query_result_multi_model(
                res,
                "",
                entity::product_status::Entity,
            )?,
            cpe: Self::from_query_result_multi_model(res, "", entity::cpe::Entity)?,
            status: Self::from_query_result_multi_model(res, "", entity::status::Entity)?,
            product_version: Self::from_query_result_multi_model_optional(
                res,
                "",
                entity::product_version::Entity,
            )?,
            sbom: Self::from_query_result_multi_model_optional(res, "", entity::sbom::Entity)?,
            sbom_node: Self::from_query_result_multi_model_optional(
                res,
                "",
                entity::sbom_node::Entity,
            )?,
        })
    }
}

impl FromQueryResultMultiModel for ProductStatusCatcher {
    fn try_into_multi_model<E: EntityTrait>(select: Select<E>) -> Result<Select<E>, DbErr> {
        select
            .try_model_columns(entity::product_status::Entity)?
            .try_model_columns(entity::cpe::Entity)?
            .try_model_columns(entity::status::Entity)?
            .try_model_columns(entity::product_version::Entity)?
            .try_model_columns(entity::sbom::Entity)?
            .try_model_columns(entity::sbom_node::Entity)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize, ToSchema)]
pub struct VulnerabilitySbomStatus {
    #[serde(flatten)]
    pub head: SbomHead,

    pub version: Option<String>,
    #[serde(skip)]
    cpe: Option<OwnedUri>,

    pub status: HashSet<String>,
}

impl VulnerabilitySbomStatus {
    async fn from_models<'i, 'j, I, J, C>(
        sbom_purl_status: I,
        products: J,
        tx: &C,
    ) -> Result<Vec<Self>, Error>
    where
        I: Iterator<Item = &'i SbomStatusCatcher> + Clone,
        J: Iterator<Item = &'j ProductStatusCatcher> + Clone,
        C: ConnectionTrait,
    {
        let mut sboms = HashMap::new();

        for status in sbom_purl_status.clone() {
            if let Entry::Vacant(e) = sboms.entry(&status.sbom.sbom_id) {
                let sbom_cpe = status.cpe.as_ref().and_then(|cpe| {
                    let sbom_cpe: Result<OwnedUri, _> = cpe.try_into();
                    sbom_cpe.ok()
                });

                e.insert(VulnerabilitySbomStatus {
                    head: SbomHead::from_entity(&status.sbom, Some(status.sbom_node.clone()), tx)
                        .await?,
                    version: status.sbom_package.version.clone(),
                    cpe: sbom_cpe,
                    status: Default::default(),
                });
            }
        }

        for product in products.clone() {
            if let Some(sbom) = &product.sbom {
                let advisory_cpe = (&product.cpe).try_into().ok();
                let entry = VulnerabilitySbomStatus {
                    head: SbomHead::from_entity(sbom, product.sbom_node.clone(), tx).await?,
                    version: product
                        .product_version
                        .as_ref()
                        .map(|pv| pv.version.clone()),
                    cpe: advisory_cpe,
                    status: vec![product.status.slug.clone()].into_iter().collect(),
                };
                sboms
                    .entry(&sbom.sbom_id)
                    .and_modify(|value| {
                        match &value.cpe {
                            Some(cpe) => {
                                // This is where the matching logic for multiple advisory entries lives
                                // At the moment we try to use the biggest range we have.
                                // For example: if we have entries for 2.0, 2.7 and 2.13 we will choose the last one
                                if let Some(version) = &product.cpe.version {
                                    let version_semver = lenient_semver::parse(version);
                                    let current_version = &cpe.version().clone().to_string();
                                    let current_semver = lenient_semver::parse(current_version);

                                    if match (&version_semver, &current_semver) {
                                        (Ok(v1), Ok(v2)) => v1 > v2,
                                        _ => false,
                                    } {
                                        *value = entry.clone()
                                    }
                                }
                            }
                            None => *value = entry.clone(),
                        }
                    })
                    .or_insert(entry);
            }
        }

        'status: for advisory_status in sbom_purl_status {
            if let Some(sbom_status) = sboms.get_mut(&advisory_status.sbom.sbom_id) {
                match (&advisory_status.context_cpe, &sbom_status.cpe) {
                    (Some(advisory_cpe), Some(sbom_cpe)) => {
                        let advisory_cpe: Result<OwnedUri, _> = advisory_cpe.try_into();

                        if let Ok(status_cpe) = advisory_cpe {
                            if status_cpe.is_superset(sbom_cpe) {
                                // the status context *is* applicable, fall through
                            } else {
                                // the status context *is not* applicable, skip
                                continue 'status;
                            }
                        } else {
                            // status_cpe is malformed, skip
                            continue 'status;
                        }
                    }
                    (Some(_), None) => {
                        // Advisory has context that does not apply to this sbom, skip
                        continue 'status;
                    }
                    (None, _) => {
                        // Advisory is not contextualized around a given CPE, fall through
                    }
                }

                sbom_status
                    .status
                    .extend(advisory_status.statuses.iter().cloned());
            }
        }

        Ok(sboms
            .drain()
            .filter_map(|(_, status)| {
                if status.status.is_empty() {
                    None
                } else {
                    Some(status)
                }
            })
            .collect())
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum SbomPackageStatus {
    Cpe(),
    Purl(PurlHead),
}
