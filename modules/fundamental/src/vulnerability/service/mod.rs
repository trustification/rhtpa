#[cfg(test)]
mod test;

use crate::{
    Error,
    advisory::model::AdvisoryHead,
    common::model::Score,
    purl::model::{
        details::{purl::PurlStatus, version_range::VersionRange},
        summary::remediation::RemediationSummary,
    },
    vulnerability::model::{
        AnalysisDetailsV3, AnalysisPurlStatus, AnalysisResponseV3, AnalysisResultV3,
        VulnerabilityDetails, VulnerabilityHead, VulnerabilitySummary,
        v2::{AnalysisAdvisory, AnalysisDetails, AnalysisResponse, AnalysisResult},
    },
};
use sea_orm::{EntityTrait, FromQueryResult, Statement, prelude::*};
use sea_query::{Expr, PgFunc};
use std::{
    collections::{BTreeMap, HashMap, btree_map::Entry},
    str::FromStr,
};
use tracing::instrument;
use trustify_common::{
    db::{
        limiter::LimiterTrait,
        query::{Columns, Filtering, Query},
    },
    memo::Memo,
    model::{Paginated, PaginatedResults},
    purl::Purl,
};
use trustify_entity::{
    advisory, advisory_vulnerability_score, organization, remediation::RemediationCategory,
    vulnerability, vulnerability_description,
};
use trustify_module_ingestor::common::Deprecation;

struct AdvisoryData {
    advisory: advisory::Model,
    issuer: Memo<organization::Model>,
}

struct AnalysisData {
    purls_with_vulnerabilities: Vec<QueryResult>,
    warnings: HashMap<String, Vec<String>>,
    descriptions_map: HashMap<String, vulnerability_description::Model>,
    scores: Vec<advisory_vulnerability_score::Model>,
    advisories_map: HashMap<Uuid, AdvisoryData>,
}

#[derive(Default)]
pub struct VulnerabilityService {}

impl VulnerabilityService {
    pub fn new() -> Self {
        Self {}
    }

    pub async fn fetch_vulnerabilities<C: ConnectionTrait + Sync + Send>(
        &self,
        search: Query,
        paginated: Paginated,
        deprecation: Deprecation,
        connection: &C,
    ) -> Result<PaginatedResults<VulnerabilitySummary>, Error> {
        let limiter = vulnerability::Entity::find()
            .filtering_with(search, Columns::from_entity::<vulnerability::Entity>())?
            .limiting(connection, paginated.offset, paginated.limit);

        let total = limiter.total().await?;
        let vulnerabilities = limiter.fetch().await?;

        Ok(PaginatedResults {
            total,
            items: VulnerabilitySummary::from_entities(&vulnerabilities, deprecation, connection)
                .await?,
        })
    }

    pub async fn fetch_vulnerability<C: ConnectionTrait + Sync + Send>(
        &self,
        identifier: &str,
        deprecation: Deprecation,
        connection: &C,
    ) -> Result<Option<VulnerabilityDetails>, Error> {
        if let Some(vulnerability) = vulnerability::Entity::find_by_id(identifier)
            .one(connection)
            .await?
        {
            Ok(Some(
                VulnerabilityDetails::from_entity(&vulnerability, deprecation, connection).await?,
            ))
        } else {
            Ok(None)
        }
    }

    #[instrument(
        skip(self, connection),
        err(level=tracing::Level::INFO),
    )]
    pub async fn delete_vulnerability<C: ConnectionTrait + Sync + Send>(
        &self,
        id: &str,
        connection: &C,
    ) -> Result<u64, Error> {
        let query = vulnerability::Entity::delete_by_id(id);

        let result = query.exec(connection).await?;

        Ok(result.rows_affected)
    }

    /// Analyze PURLs and return vulnerability data in the v3 response format.
    ///
    /// V3 response uses `AnalysisResponseV3` / `AnalysisResultV3` / `AnalysisDetailsV3`.
    #[instrument(
        skip_all,
        err(level=tracing::Level::INFO),
    )]
    pub async fn analyze_purls_v3<C>(
        &self,
        purls: impl IntoIterator<Item = impl AsRef<str>>,
        connection: &C,
    ) -> Result<AnalysisResponseV3, Error>
    where
        C: ConnectionTrait,
    {
        let data = self
            .fetch_vulnerability_analysis_data(purls, connection)
            .await?;
        self.format_response(data, connection).await
    }

    /// Analyze PURLs and return vulnerability data in the legacy v2 response format.
    ///
    /// V2 response uses `AnalysisResponse` / `AnalysisResult` / `AnalysisDetails` / `AnalysisAdvisory`.
    #[instrument(
        skip_all,
        err(level=tracing::Level::INFO),
    )]
    pub async fn analyze_purls_v2<C>(
        &self,
        purls: impl IntoIterator<Item = impl AsRef<str>>,
        connection: &C,
    ) -> Result<AnalysisResponse, Error>
    where
        C: ConnectionTrait,
    {
        let data = self
            .fetch_vulnerability_analysis_data(purls, connection)
            .await?;
        self.format_response_v2(data, connection).await
    }

    async fn fetch_vulnerability_analysis_data<C>(
        &self,
        purls: impl IntoIterator<Item = impl AsRef<str>>,
        connection: &C,
    ) -> Result<AnalysisData, Error>
    where
        C: ConnectionTrait,
    {
        let mut warnings = HashMap::new();
        let query = Self::build_query(purls, connection, &mut warnings)?;

        let stmt = Statement::from_string(connection.get_database_backend(), query);
        log::debug!("Analyzing using: {stmt}");

        // Collect all query results
        let purls_with_vulnerabilities = connection.query_all(stmt).await.map_err(Error::from)?;
        log::debug!(
            "Pre-fetched {} purl vulnerability matches",
            purls_with_vulnerabilities.len()
        );

        // Extract advisory IDs from JSONB array
        #[derive(serde::Deserialize)]
        struct AdvisoryEntry {
            advisory_id: Uuid,
        }
        impl sea_orm::TryGetableFromJson for AdvisoryEntry {}

        // Extract all unique vulnerability_ids and advisory_ids in a single pass
        let mut vulnerability_ids: Vec<String> =
            Vec::with_capacity(purls_with_vulnerabilities.len());
        let mut advisory_ids_set: std::collections::HashSet<Uuid> =
            std::collections::HashSet::new();

        for purl_with_vulnerabilities in &purls_with_vulnerabilities {
            vulnerability_ids.push(purl_with_vulnerabilities.try_get("", "id")?);

            if let Some(advisories) = purl_with_vulnerabilities
                .try_get_by::<Option<Vec<AdvisoryEntry>>, _>("advisories")?
            {
                advisory_ids_set.extend(advisories.into_iter().map(|e| e.advisory_id));
            }
        }

        let advisory_ids: Vec<Uuid> = advisory_ids_set.into_iter().collect();

        // Pre-fetch vulnerability descriptions
        let vulnerability_descriptions = if !vulnerability_ids.is_empty() {
            vulnerability_description::Entity::find()
                .filter(
                    Expr::col(vulnerability_description::Column::VulnerabilityId)
                        .eq(PgFunc::any(vulnerability_ids.clone())),
                )
                .filter(vulnerability_description::Column::Lang.eq("en"))
                .all(connection)
                .await?
        } else {
            vec![]
        };
        log::debug!(
            "Pre-fetched {} vulnerability descriptions",
            vulnerability_descriptions.len()
        );

        let descriptions_map: HashMap<String, vulnerability_description::Model> =
            vulnerability_descriptions
                .into_iter()
                .map(|desc| (desc.vulnerability_id.clone(), desc))
                .collect();

        // Pre-fetch scores from advisory_vulnerability_score table
        let scores = if !advisory_ids.is_empty() && !vulnerability_ids.is_empty() {
            advisory_vulnerability_score::Entity::find()
                .filter(
                    Expr::col(advisory_vulnerability_score::Column::AdvisoryId)
                        .eq(PgFunc::any(advisory_ids.clone())),
                )
                .filter(
                    Expr::col(advisory_vulnerability_score::Column::VulnerabilityId)
                        .eq(PgFunc::any(vulnerability_ids)),
                )
                .all(connection)
                .await?
        } else {
            vec![]
        };
        log::debug!("Pre-fetched {} scores", scores.len());

        // Pre-fetch advisories
        let advisories = if !advisory_ids.is_empty() {
            advisory::Entity::find()
                .filter(Expr::col(advisory::Column::Id).eq(PgFunc::any(advisory_ids)))
                .all(connection)
                .await?
        } else {
            vec![]
        };
        log::debug!("Pre-fetched {} advisories", advisories.len());

        let organizations = advisories
            .load_one(organization::Entity, connection)
            .await?;

        let advisories = advisories
            .iter()
            .zip(organizations)
            .map(|(advisory, org)| {
                (
                    advisory.id,
                    AdvisoryData {
                        advisory: advisory.clone(),
                        issuer: Memo::Provided(org),
                    },
                )
            })
            .collect();

        Ok(AnalysisData {
            purls_with_vulnerabilities,
            warnings,
            descriptions_map,
            scores,
            advisories_map: advisories,
        })
    }

    /// Format vulnerability analysis data into the v3 response structure.
    async fn format_response<C>(
        &self,
        data: AnalysisData,
        connection: &C,
    ) -> Result<AnalysisResponseV3, Error>
    where
        C: ConnectionTrait,
    {
        let AnalysisData {
            purls_with_vulnerabilities,
            mut warnings,
            descriptions_map,
            scores,
            advisories_map,
        } = data;

        // Build a map of (advisory_id, vulnerability_id) -> Vec<Model> for score calculation
        let mut scores_map: HashMap<(Uuid, String), Vec<advisory_vulnerability_score::Model>> =
            HashMap::new();
        for score in scores {
            scores_map
                .entry((score.advisory_id, score.vulnerability_id.clone()))
                .or_default()
                .push(score);
        }

        let mut result = BTreeMap::new();

        for row in purls_with_vulnerabilities {
            let (requested_purl, head) = Self::row_to_vuln_v3(
                row,
                connection,
                &descriptions_map,
                &scores_map,
                &advisories_map,
            )
            .await?;

            match result.entry(requested_purl.clone()) {
                Entry::Vacant(entry) => {
                    entry.insert(AnalysisResultV3 {
                        details: vec![head],
                        warnings: warnings.remove(&requested_purl).unwrap_or_default(),
                    });
                }
                Entry::Occupied(mut entry) => {
                    entry.get_mut().details.push(head);
                }
            }
        }

        // add the remaining warnings
        for (purl, warnings) in warnings {
            result.entry(purl).or_default().warnings.extend(warnings);
        }

        Ok(AnalysisResponseV3(result))
    }

    /// Format vulnerability analysis data into the v2 response structure.
    async fn format_response_v2<C>(
        &self,
        data: AnalysisData,
        connection: &C,
    ) -> Result<AnalysisResponse, Error>
    where
        C: ConnectionTrait,
    {
        let AnalysisData {
            purls_with_vulnerabilities,
            mut warnings,
            descriptions_map,
            scores,
            advisories_map,
        } = data;

        let mut scores_map: HashMap<(Uuid, String), Vec<Score>> = HashMap::new();
        for score in scores {
            let converted_score = Score::from(score.clone());
            scores_map
                .entry((score.advisory_id, score.vulnerability_id))
                .or_default()
                .push(converted_score);
        }

        let mut result = BTreeMap::new();

        for row in purls_with_vulnerabilities {
            let (requested_purl, head) = Self::row_to_vuln_v2(
                row,
                connection,
                &descriptions_map,
                &scores_map,
                &advisories_map,
            )
            .await?;

            match result.entry(requested_purl.clone()) {
                Entry::Vacant(entry) => {
                    entry.insert(AnalysisResult {
                        details: vec![head],
                        warnings: warnings.remove(&requested_purl).unwrap_or_default(),
                    });
                }
                Entry::Occupied(mut entry) => {
                    entry.get_mut().details.push(head);
                }
            }
        }

        // add the remaining warnings
        for (purl, warnings) in warnings {
            result.entry(purl).or_default().warnings.extend(warnings);
        }

        Ok(AnalysisResponse(result))
    }

    /// Build the query for finding matching vulnerabilities
    fn build_query(
        purls: impl IntoIterator<Item = impl AsRef<str>>,
        connection: &impl ConnectionTrait,
        warnings: &mut HashMap<String, Vec<String>>,
    ) -> Result<String, Error> {
        let query = purls
            .into_iter()
            .map(|p| {
                let p = p.as_ref();
                let purl = Purl::from_str(p)?;

                let Some(version) = purl.version else {
                    warnings
                        .entry(p.to_string())
                        .or_default()
                        .push("Unable to process: missing version component".to_string());
                    return Ok(None);
                };

                let ns_condition = match &purl.namespace {
                    Some(namespace) => {
                        let sql = "base_purl.namespace = $1";
                        Statement::from_sql_and_values(
                            connection.get_database_backend(),
                            sql,
                            [namespace.into()],
                        )
                        .to_string()
                    }
                    None => "base_purl.namespace IS NULL".to_string(),
                };

                let sql = format!(
                    r#"
SELECT
  $1 as requested_purl,
  vulnerability.id,
  vulnerability.title,
  vulnerability.reserved,
  vulnerability.published,
  vulnerability.modified,
  vulnerability.withdrawn,
  vulnerability.cwes,
  jsonb_agg(
    DISTINCT jsonb_build_object(
        'status', status.slug,
        'advisory_id', purl_status.advisory_id,
        'version_range', jsonb_build_object(
            'version_scheme_id', version_range.version_scheme_id,
            'low_version', version_range.low_version,
            'low_inclusive', version_range.low_inclusive,
            'high_version', version_range.high_version,
            'high_inclusive', version_range.high_inclusive
        ),
        'remediations', (
            SELECT COALESCE(jsonb_agg(
                jsonb_build_object(
                    'id', r.id,
                    'category', r.category,
                    'details', r.details,
                    'url', r.url,
                    'data', r.data
                )
            ), '[]'::jsonb)
            FROM remediation_purl_status rps
            JOIN remediation r ON r.id = rps.remediation_id
            WHERE rps.purl_status_id = purl_status.id
        )
    )
  ) AS advisories
FROM base_purl
  LEFT JOIN purl_status ON base_purl.id = purl_status.base_purl_id
  INNER JOIN version_range ON purl_status.version_range_id = version_range.id
  LEFT JOIN vulnerability ON purl_status.vulnerability_id = vulnerability.id
  INNER JOIN status ON purl_status.status_id = status.id
WHERE {ns_condition}
  AND base_purl.name = $2
  AND base_purl.type = $3
  AND version_matches($4, version_range.*) = TRUE
  AND status.slug NOT IN (
    'fixed',
    'not_affected',
    'recommended'
  )
GROUP BY
  vulnerability.id,
  vulnerability.title,
  vulnerability.reserved,
  vulnerability.published,
  vulnerability.modified,
  vulnerability.withdrawn,
  vulnerability.cwes,
  requested_purl
"#
                );
                let query = Statement::from_sql_and_values(
                    connection.get_database_backend(),
                    &sql,
                    [p.into(), purl.name.into(), purl.ty.into(), version.into()],
                );

                Ok(Some(query.to_string()))
            })
            .filter_map(Result::transpose)
            .collect::<Result<Vec<String>, Error>>()?
            .join(" UNION ALL ");

        Ok(query)
    }

    /// Take a row from [`Self::build_query`] and turn it into a result entry
    ///
    /// This will return a tuple of the original PURL and then the result
    #[instrument(
        skip_all,
        fields(purl, id),
        err(level=tracing::Level::INFO),
    )]
    async fn row_to_vuln_v3<C>(
        row: QueryResult,
        connection: &C,
        descriptions_map: &HashMap<String, vulnerability_description::Model>,
        scores_map: &HashMap<(Uuid, String), Vec<advisory_vulnerability_score::Model>>,
        advisories_map: &HashMap<Uuid, AdvisoryData>,
    ) -> Result<(String, AnalysisDetailsV3), Error>
    where
        C: ConnectionTrait,
    {
        let requested_purl: String = row.try_get_by("requested_purl")?;

        let vulnerability = vulnerability::Model::from_query_result(&row, "")?;

        let span = tracing::Span::current();
        span.record("purl", &requested_purl);
        span.record("id", &vulnerability.id);

        // Look up description from pre-fetched map
        let description_memo = descriptions_map
            .get(&vulnerability.id)
            .map(|desc| Memo::Provided(Some(desc.clone())))
            .unwrap_or(Memo::Provided(None));

        let head = VulnerabilityHead::from_vulnerability_entity(
            &vulnerability,
            description_memo,
            connection,
        )
        .await?;

        /// result struct for getting the array of status/advisory entries
        #[derive(Debug, serde::Deserialize)]
        struct AdvisoryEntry {
            status: String,
            advisory_id: Uuid,
            version_range: VersionRange,
            remediations: Vec<RemediationEntry>,
        }
        impl sea_orm::TryGetableFromJson for AdvisoryEntry {}

        #[derive(Debug, Clone, serde::Deserialize)]
        struct RemediationEntry {
            id: Uuid,
            category: RemediationCategory,
            details: Option<String>,
            url: Option<String>,
            data: serde_json::Value,
        }

        // deserialize from JSONB
        let advisories: Option<Vec<AdvisoryEntry>> = row.try_get_by("advisories")?;

        // create a map for looking up the status once we resolved the ID to a struct
        let statuses = advisories.into_iter().flatten().fold(
            BTreeMap::new(),
            |mut acc: BTreeMap<Uuid, Vec<AdvisoryEntry>>, entry| {
                match acc.entry(entry.advisory_id) {
                    Entry::Occupied(mut occupied_entry) => {
                        occupied_entry.get_mut().push(entry);
                    }
                    Entry::Vacant(vacant_entry) => {
                        vacant_entry.insert(vec![entry]);
                    }
                };
                acc
            },
        );

        let mut purl_statuses = Vec::new();

        for (advisory_id, entries) in &statuses {
            let Some(advisory) = advisories_map.get(advisory_id) else {
                continue;
            };

            // Look up scores from pre-fetched map
            let score_models = scores_map
                .get(&(*advisory_id, vulnerability.id.clone()))
                .map(|v| v.as_slice())
                .unwrap_or(&[]);

            for entry in entries {
                let remediations: Vec<RemediationSummary> = entry
                    .remediations
                    .iter()
                    .map(|r| RemediationSummary {
                        id: r.id,
                        category: r.category.clone(),
                        details: r.details.clone(),
                        url: r.url.clone(),
                        data: r.data.clone(),
                    })
                    .collect();

                let purl_status = PurlStatus::from_head(
                    head.clone(),
                    AdvisoryHead::from_advisory(
                        &advisory.advisory,
                        advisory.issuer.clone(),
                        connection,
                    )
                    .await?,
                    entry.status.clone(),
                    Some(entry.version_range.clone()),
                    None,
                    score_models,
                )?;
                purl_statuses.push(AnalysisPurlStatus {
                    purl_status,
                    remediations,
                });
            }
        }

        Ok((
            requested_purl,
            AnalysisDetailsV3 {
                head,
                purl_statuses,
            },
        ))
    }

    /// Take a row from [`Self::build_query`] and turn it into a result entry
    ///
    /// This will return a tuple of the original PURL and then the result
    #[instrument(
        skip_all,
        fields(purl, id),
        err(level=tracing::Level::INFO),
    )]
    async fn row_to_vuln_v2<C>(
        row: QueryResult,
        connection: &C,
        descriptions_map: &HashMap<String, vulnerability_description::Model>,
        scores_map: &HashMap<(Uuid, String), Vec<Score>>,
        advisories_map: &HashMap<Uuid, AdvisoryData>,
    ) -> Result<(String, AnalysisDetails), Error>
    where
        C: ConnectionTrait,
    {
        let requested_purl: String = row.try_get_by("requested_purl")?;

        let vulnerability = vulnerability::Model::from_query_result(&row, "")?;

        let span = tracing::Span::current();
        span.record("purl", &requested_purl);
        span.record("id", &vulnerability.id);

        // Look up description from pre-fetched map
        let description_memo = descriptions_map
            .get(&vulnerability.id)
            .map(|desc| Memo::Provided(Some(desc.clone())))
            .unwrap_or(Memo::Provided(None));

        let head = VulnerabilityHead::from_vulnerability_entity(
            &vulnerability,
            description_memo,
            connection,
        )
        .await?;

        /// result struct for getting the array of status/advisory entries
        #[derive(serde::Deserialize)]
        struct AdvisoryEntry {
            status: String,
            advisory_id: Uuid,
        }
        impl sea_orm::TryGetableFromJson for AdvisoryEntry {}

        // deserialize from JSONB

        let advisories: Option<Vec<AdvisoryEntry>> = row.try_get_by("advisories")?;

        // create a map for looking up the status once we resolved the ID to a struct
        // This also de-duplicates advisory IDs
        let statuses = advisories
            .into_iter()
            .flatten()
            .map(|e| (e.advisory_id, e.status))
            .collect::<HashMap<_, _>>();

        // Process advisories using pre-fetched data
        let mut status_map = BTreeMap::<String, Vec<AnalysisAdvisory>>::new();

        for (advisory_id, status) in &statuses {
            let Some(advisory) = advisories_map.get(advisory_id) else {
                continue;
            };

            // Look up scores from pre-fetched scores_map
            let scores: Vec<Score> = scores_map
                .get(&(*advisory_id, vulnerability.id.clone()))
                .cloned()
                .unwrap_or_default();

            let analysis_advisory = AnalysisAdvisory {
                advisory: AdvisoryHead::from_advisory(
                    &advisory.advisory,
                    advisory.issuer.clone(),
                    connection,
                )
                .await?,
                scores,
            };

            status_map
                .entry(status.clone())
                .or_default()
                .push(analysis_advisory);
        }

        Ok((
            requested_purl,
            AnalysisDetails {
                head,
                status: status_map,
            },
        ))
    }
}
