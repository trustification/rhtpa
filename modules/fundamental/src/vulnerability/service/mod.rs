use crate::{
    vulnerability::model::{VulnerabilityDetails, VulnerabilitySummary},
    Error,
};
use sea_orm::{prelude::*, EntityTrait, FromQueryResult, IntoIdentity, QuerySelect, QueryTrait};
use sea_query::{ColumnRef, Func, IntoColumnRef, IntoIden, SimpleExpr};
use trustify_common::{
    db::{
        limiter::LimiterAsModelTrait,
        multi_model::{FromQueryResultMultiModel, SelectIntoMultiModel},
        query::{Columns, Filtering, Query},
    },
    model::{Paginated, PaginatedResults},
};
use trustify_entity::{
    cvss3::{self, Severity},
    vulnerability,
};
use trustify_module_ingestor::common::Deprecation;

#[derive(Default)]
pub struct VulnerabilityService {}

impl VulnerabilityService {
    pub fn new() -> Self {
        Self {}
    }

    pub async fn fetch_vulnerabilities<C: ConnectionTrait + Sync + Send>(
        &self,
        search: Query,
        paginated: Paginated,
        deprecation: Deprecation,
        connection: &C,
    ) -> Result<PaginatedResults<VulnerabilitySummary>, Error> {
        let inner_query = vulnerability::Entity::find()
            .left_join(cvss3::Entity)
            .expr_as_(
                SimpleExpr::FunctionCall(Func::avg(SimpleExpr::Column(
                    trustify_entity::cvss3::Column::Score.into_column_ref(),
                ))),
                "average_score",
            )
            .expr_as_(
                SimpleExpr::FunctionCall(Func::cust("cvss3_severity".into_identity()).arg(
                    SimpleExpr::FunctionCall(Func::avg(SimpleExpr::Column(
                        trustify_entity::cvss3::Column::Score.into_column_ref(),
                    ))),
                )),
                "average_severity",
            )
            .group_by(vulnerability::Column::Id);

        let mut outer_query = vulnerability::Entity::find();

        // Alias the inner query as exactly the table the entity is expecting
        // so that column aliases link up correctly.
        QueryTrait::query(&mut outer_query)
            .from_clear()
            .from_subquery(inner_query.into_query(), "vulnerability".into_identity());

        let limiter = outer_query
            .column_as(
                SimpleExpr::Column(ColumnRef::Column(
                    "average_score".into_identity().into_iden(),
                )),
                "average_score",
            )
            .column_as(
                SimpleExpr::Column(ColumnRef::Column(
                    "average_severity".into_identity().into_iden(),
                ))
                .cast_as("TEXT".into_identity()),
                "average_severity",
            )
            .filtering_with(
                search,
                Columns::from_entity::<vulnerability::Entity>()
                    .add_column("average_score", ColumnType::Decimal(None).def())
                    .add_column(
                        "average_severity",
                        ColumnType::Enum {
                            name: "cvss3_severity".into_identity().into_iden(),
                            variants: vec![
                                "none".into_identity().into_iden(),
                                "low".into_identity().into_iden(),
                                "medium".into_identity().into_iden(),
                                "high".into_identity().into_iden(),
                                "critical".into_identity().into_iden(),
                            ],
                        }
                        .def(),
                    )
                    .translator(|f, op, v| match (f, v) {
                        // v = "" for all sort fields
                        ("average_severity", "") => Some(format!("average_score:{op}")),
                        _ => None,
                    }),
            )?
            .try_limiting_as_multi_model::<VulnerabilityCatcher>(
                connection,
                paginated.offset,
                paginated.limit,
            )?;

        let total = limiter.total().await?;
        let caught = limiter.fetch().await?;
        let vulnerabilities = caught
            .iter()
            .map(|e| e.vulnerability.clone())
            .collect::<Vec<_>>();
        let averages = caught
            .iter()
            .map(|e| (e.average_score, e.average_severity.map(|s| s.into())))
            .collect::<Vec<_>>();

        Ok(PaginatedResults {
            total,
            items: VulnerabilitySummary::from_entities(
                &vulnerabilities,
                &averages,
                deprecation,
                connection,
            )
            .await?,
        })
    }

    pub async fn fetch_vulnerability<C: ConnectionTrait + Sync + Send>(
        &self,
        identifier: &str,
        deprecation: Deprecation,
        connection: &C,
    ) -> Result<Option<VulnerabilityDetails>, Error> {
        if let Some(vulnerability) = vulnerability::Entity::find_by_id(identifier)
            .one(connection)
            .await?
        {
            Ok(Some(
                VulnerabilityDetails::from_entity(&vulnerability, deprecation, connection).await?,
            ))
        } else {
            Ok(None)
        }
    }

    pub async fn delete_vulnerability<C: ConnectionTrait + Sync + Send>(
        &self,
        id: &str,
        connection: &C,
    ) -> Result<u64, Error> {
        let query = vulnerability::Entity::delete_by_id(id);

        let result = query.exec(connection).await?;

        Ok(result.rows_affected)
    }
}

#[derive(Debug)]
struct VulnerabilityCatcher {
    pub vulnerability: vulnerability::Model,
    pub average_score: Option<f64>,
    pub average_severity: Option<Severity>,
}

impl FromQueryResult for VulnerabilityCatcher {
    fn from_query_result(res: &QueryResult, _pre: &str) -> Result<Self, DbErr> {
        Ok(Self {
            vulnerability: Self::from_query_result_multi_model(res, "", vulnerability::Entity)?,
            average_score: res.try_get("", "average_score")?,
            average_severity: res.try_get("", "average_severity")?,
        })
    }
}

impl FromQueryResultMultiModel for VulnerabilityCatcher {
    fn try_into_multi_model<E: EntityTrait>(select: Select<E>) -> Result<Select<E>, DbErr> {
        select.try_model_columns(vulnerability::Entity)
    }
}

#[cfg(test)]
mod test;
