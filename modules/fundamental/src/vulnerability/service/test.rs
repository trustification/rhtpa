use std::str::FromStr;

use crate::purl::model::details::purl::StatusContext;
use crate::purl::service::PurlService;
use crate::sbom::service::SbomService;
use crate::vulnerability::service::VulnerabilityService;
use test_context::test_context;
use test_log::test;
use trustify_common::db::query::{q, Query};
use trustify_common::model::Paginated;
use trustify_common::purl::Purl;
use trustify_test_context::TrustifyContext;

#[test_context(TrustifyContext)]
#[test(actix_web::test)]
async fn all_vulnerabilities(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents(["osv/RUSTSEC-2021-0079.json", "cve/CVE-2021-32714.json"])
        .await?;

    let vulns = service
        .fetch_vulnerabilities(
            Query::default(),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;

    assert_eq!(1, vulns.items.len());

    assert!(vulns.items[0]
        .head
        .description
        .as_ref()
        .unwrap()
        .starts_with("hyper is an HTTP library for Rust"));

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(actix_web::test)]
async fn statuses(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents(["osv/RUSTSEC-2021-0079.json", "cve/CVE-2021-32714.json"])
        .await?;

    let vuln = service
        .fetch_vulnerability("CVE-2021-32714", Default::default(), &ctx.db)
        .await?;

    assert!(vuln.is_some());

    let vuln = vuln.unwrap();

    assert_eq!(2, vuln.advisories.len());

    log::debug!("{vuln:#?}");

    let rustsec_advisory = vuln
        .advisories
        .iter()
        .find(|e| e.head.head.identifier == "RUSTSEC-2021-0079");
    assert!(rustsec_advisory.is_some());
    let rustsec_advisory = rustsec_advisory.unwrap();

    let cve_advisory = vuln
        .advisories
        .iter()
        .find(|e| e.head.head.identifier == "CVE-2021-32714");
    assert!(cve_advisory.is_some());
    let cve_advisory = cve_advisory.unwrap();

    let rustsec_statuses: Vec<_> = rustsec_advisory.purls.keys().collect();

    assert_eq!(2, rustsec_statuses.len());
    assert!(rustsec_statuses.contains(&&"fixed".to_string()));
    assert!(rustsec_statuses.contains(&&"affected".to_string()));

    let cve_statuses: Vec<_> = cve_advisory.purls.keys().collect();
    assert_eq!(0, cve_statuses.len());

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(actix_web::test)]
async fn statuses_too(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents([
        "cve/CVE-2024-29025.json",
        "csaf/rhsa-2024-2705.json",
        "spdx/quarkus-bom-3.2.11.Final-redhat-00001.json",
        "spdx/quarkus-bom-3.2.12.Final-redhat-00002.json",
    ])
    .await?;

    let vuln = service
        .fetch_vulnerability("CVE-2024-29025", Default::default(), &ctx.db)
        .await?;

    assert!(vuln.is_some());

    let vuln = vuln.unwrap();

    log::debug!("{vuln:#?}");

    assert_eq!(2, vuln.advisories.len());

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(actix_web::test)]
async fn commons_compress(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let vuln_service = VulnerabilityService::new();
    let sbom_service = SbomService::new(ctx.db.clone());

    // Ingest a CVE declaring the vulnerability present in versions
    // [1.21,1.26.0) of commons-compress, along with 2 sboms, each of
    // which includes a vulnerable version of commons-compress
    let ingest_results = ctx
        .ingest_documents([
            "cve/CVE-2024-26308.json",
            "spdx/SATELLITE-6.15-RHEL-8.json", // 1.21
            "spdx/OCP-TOOLS-4.11-RHEL-8.json", // 1.24
            "spdx/quarkus-bom-3.2.11.Final-redhat-00001.json", // 1.26.0.redhat-00001
        ])
        .await?;

    let sat_id = ingest_results[1].id.clone();

    let sat_sbom = sbom_service.fetch_sbom_details(sat_id, &ctx.db).await?;
    assert!(sat_sbom.is_some());

    let sat_sbom = sat_sbom.unwrap();
    assert_eq!(1, sat_sbom.advisories.len());

    let sat_status = &sat_sbom.advisories[0].status[0];

    // first, ensure our assumptions are correct and
    // the pURL is indeed part of the SBOM we think
    // it is.
    assert_eq!(sat_status.status, "affected");

    assert_eq!(1, sat_status.packages.len());

    assert_eq!(
        sat_status.packages[0].purl[0].head.purl.to_string(),
        "pkg:maven/org.apache.commons/commons-compress@1.21"
    );

    let quarkus_id = ingest_results[3].id.clone();

    let quarkus_sbom = sbom_service.fetch_sbom_details(quarkus_id, &ctx.db).await?;

    assert!(quarkus_sbom.is_some());

    let quarkus_sbom = quarkus_sbom.unwrap();

    // Quarkus should /not/ be affected.
    assert!(quarkus_sbom.advisories.is_empty());

    let vuln = vuln_service
        .fetch_vulnerability("CVE-2024-26308", Default::default(), &ctx.db)
        .await?
        .unwrap();

    log::debug!("{vuln:#?}");

    assert_eq!(
        "pkg:maven/org.apache.commons/commons-compress",
        vuln.advisories[0].purls["affected"][0]
            .base_purl
            .purl
            .to_string()
    );
    assert_eq!(
        "[1.21,1.26.0)",
        vuln.advisories[0].purls["affected"][0].version.to_string()
    );

    // Now, ensure that vuln->sbom mapping is good.
    let mut sboms: Vec<_> = vuln.advisories[0]
        .sboms
        .iter()
        .map(|i| i.head.document_id.as_str())
        .collect();
    sboms.sort();

    assert_eq!(
        sboms,
        [
            "https://access.redhat.com/security/data/sbom/spdx/OCP-TOOLS-4.11-RHEL-8",
            "https://access.redhat.com/security/data/sbom/spdx/SATELLITE-6.15-RHEL-8",
        ],
    );

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(actix_web::test)]
async fn product_statuses(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let vuln_service = VulnerabilityService::new();
    let sbom_service = SbomService::new(ctx.db.clone());
    let purl_service = PurlService::new();

    let ingest_results = ctx
        .ingest_documents([
            "csaf/cve-2023-0044.json",
            "quarkus/v2/quarkus-bom-2.13.8.Final-redhat-00004.json",
        ])
        .await?;

    let quarkus_id = ingest_results[1].id.clone();

    let quarkus_sbom = sbom_service.fetch_sbom_details(quarkus_id, &ctx.db).await?;

    assert!(quarkus_sbom.is_some());

    let quarkus_sbom = quarkus_sbom.unwrap();

    log::debug!("{quarkus_sbom:#?}");

    assert!(!quarkus_sbom.advisories.is_empty());
    let quarkus_adv = &quarkus_sbom.advisories[0].status[0];

    assert_eq!(quarkus_adv.status, "fixed");
    assert_eq!(quarkus_adv.vulnerability.identifier, "CVE-2023-0044");

    let quarkus_adv = &quarkus_sbom.advisories[0].status[1];
    assert_eq!(quarkus_adv.packages.len(), 1);
    assert_eq!(quarkus_adv.packages[0].purl.len(), 1);
    assert_eq!(quarkus_adv.packages[0].purl[0].head.purl, Purl::from_str("pkg:maven/io.quarkus/quarkus-vertx-http@2.13.8.Final-redhat-00004?repository_url=https://maven.repository.redhat.com/ga/&type=jar").unwrap());

    let vuln = vuln_service
        .fetch_vulnerability("CVE-2023-0044", Default::default(), &ctx.db)
        .await?;

    assert!(vuln.is_some());

    let vuln = vuln.unwrap();

    log::debug!("{vuln:#?}");

    assert_eq!(1, vuln.advisories.len());

    let cve_advisory = vuln
        .advisories
        .iter()
        .find(|e| e.head.head.identifier == "https://www.redhat.com/#CVE-2023-0044");
    assert!(cve_advisory.is_some());
    let cve_advisory = cve_advisory.unwrap();

    log::debug!("{cve_advisory:#?}");

    assert_eq!(
        "pkg:generic/io.quarkus/quarkus-vertx-http",
        cve_advisory.purls["affected"][0].base_purl.purl.to_string()
    );
    assert_eq!("*", cve_advisory.purls["affected"][0].version.to_string());
    if let Some(StatusContext::Cpe(ref cpe_value)) = cve_advisory.purls["affected"][0].context {
        assert_eq!(cpe_value, "cpe:/a:redhat:quarkus:2:*:*:*");
    } else {
        panic!("Expected Cpe context");
    }

    // Ensure that vuln->sbom mapping is good.
    let mut sboms: Vec<_> = vuln.advisories[0]
        .sboms
        .iter()
        .map(|i| i.head.document_id.as_str())
        .collect();
    sboms.sort();

    assert_eq!(
        sboms,
        [
            "https://access.redhat.com/security/data/sbom/spdx/quarkus-bom-2.13.8.Final-redhat-00004",
        ],
    );

    // Ensure that purl->vuln mapping is good
    let purl = purl_service
        .purl_by_purl(
            &Purl::try_from("pkg:maven/io.quarkus/quarkus-vertx-http@2.13.8.Final-redhat-00004")?,
            Default::default(),
            &ctx.db,
        )
        .await?;

    log::debug!("{:#?}", purl);
    assert!(purl.is_some());
    let purl = purl.unwrap();
    assert_eq!(1, purl.advisories.len());

    let cve_advisory = purl
        .advisories
        .iter()
        .find(|e| e.head.identifier == "https://www.redhat.com/#CVE-2023-0044");
    assert!(cve_advisory.is_some());

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(actix_web::test)]
async fn delete_vulnerability(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents(["cve/CVE-2024-29025.json"]).await?;

    let vuln = service
        .fetch_vulnerability("CVE-2024-29025", Default::default(), &ctx.db)
        .await?
        .expect("Vulnerability not found");

    assert_eq!(1, vuln.advisories.len());

    let id = &vuln.advisories[0].head.head.identifier;

    let affected = service.delete_vulnerability(id, &ctx.db).await?;
    assert_eq!(1, affected);

    assert!(service
        .fetch_vulnerability("CVE-2024-29025", Default::default(), &ctx.db)
        .await?
        .is_none());

    let affected = service.delete_vulnerability(id, &ctx.db).await?;
    assert_eq!(0, affected);

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(actix_web::test)]
async fn vulnerability_queries(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents([
        "csaf/CVE-2023-20862.json",
        "csaf/RHBA-2024_1440.json",
        "csaf/rhsa-2023_5835.json",
    ])
    .await?;

    let vulns = service
        .fetch_vulnerabilities(q(""), Paginated::default(), Default::default(), &ctx.db)
        .await?;
    assert_eq!(5, vulns.items.len());
    let vulns = service
        .fetch_vulnerabilities(
            q("average_score>9"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(vulns.items[0].head.identifier, "CVE-2023-42282");
    let vulns = service
        .fetch_vulnerabilities(
            q("average_severity=critical"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(vulns.items[0].head.identifier, "CVE-2023-42282");
    let vulns = service
        .fetch_vulnerabilities(
            q("average_severity<high"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(
        *vulns.items[0].average_severity.as_ref().unwrap(),
        trustify_cvss::cvss3::severity::Severity::Medium
    );
    let vulns = service
        .fetch_vulnerabilities(
            q("average_severity>=high"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(4, vulns.items.len());
    let vulns = service
        .fetch_vulnerabilities(
            q("20862"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(vulns.items[0].head.identifier, "CVE-2023-20862");

    Ok(())
}
