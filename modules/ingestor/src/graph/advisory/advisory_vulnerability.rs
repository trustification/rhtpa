use crate::graph::{advisory::AdvisoryContext, error::Error, vulnerability::VulnerabilityContext};
use sea_orm::{
    ActiveModelTrait, ColumnTrait, ConnectionTrait, EntityTrait, IntoIdentity, NotSet, QueryFilter,
    Set,
};
use sea_query::{Condition, Expr, IntoCondition};
use tracing::instrument;
use trustify_common::{cpe::Cpe, purl::Purl};
use trustify_cvss::cvss3::Cvss3Base;
use trustify_entity::{
    self as entity, cvss3::Severity, purl_status, status, version_range,
    version_scheme::VersionScheme, vulnerability,
};

#[derive(Clone, Eq, Hash, Debug, PartialEq)]
pub struct VersionInfo {
    pub scheme: VersionScheme,
    pub spec: VersionSpec,
}

#[derive(Clone, Eq, Hash, Debug, PartialEq)]
pub enum VersionSpec {
    Exact(String),
    Range(Version, Version),
}

#[derive(Clone, Eq, Hash, Debug, PartialEq)]
pub enum Version {
    Inclusive(String),
    Exclusive(String),
    Unbounded,
}

impl VersionInfo {
    pub fn into_active_model(self) -> version_range::ActiveModel {
        version_range::ActiveModel {
            id: Default::default(),
            version_scheme_id: Set(self.scheme),
            low_version: Set(match &self.spec {
                VersionSpec::Exact(version) => Some(version.clone()),
                VersionSpec::Range(low, _) => match low {
                    Version::Inclusive(version) | Version::Exclusive(version) => {
                        Some(version.clone())
                    }
                    Version::Unbounded => None,
                },
            }),
            low_inclusive: Set(match &self.spec {
                VersionSpec::Exact(_) => Some(true),
                VersionSpec::Range(low, _) => match low {
                    Version::Inclusive(_) => Some(true),
                    _ => Some(false),
                },
            }),
            high_version: Set(match &self.spec {
                VersionSpec::Exact(version) => Some(version.clone()),
                VersionSpec::Range(_, high) => match high {
                    Version::Inclusive(version) | Version::Exclusive(version) => {
                        Some(version.clone())
                    }
                    Version::Unbounded => None,
                },
            }),
            high_inclusive: Set(match &self.spec {
                VersionSpec::Exact(_) => Some(true),
                VersionSpec::Range(_, high) => match high {
                    Version::Inclusive(_) => Some(true),
                    _ => Some(false),
                },
            }),
        }
    }
}

impl IntoCondition for VersionInfo {
    fn into_condition(self) -> Condition {
        match self.spec {
            VersionSpec::Exact(version) => Condition::all()
                .add(Expr::col("version_scheme_id".into_identity()).eq(self.scheme))
                .add(Expr::col("low_version".into_identity()).eq(version.clone()))
                .add(Expr::col("low_inclusive".into_identity()).eq(true))
                .add(Expr::col("high_version".into_identity()).eq(version))
                .add(Expr::col("high_inclusive".into_identity()).eq(true)),

            VersionSpec::Range(low, high) => {
                let low_cond = match low {
                    Version::Inclusive(version) => Condition::all()
                        .add(Expr::col("low_version".into_identity()).eq(version))
                        .add(Expr::col("low_inclusive".into_identity()).eq(true)),
                    Version::Exclusive(version) => Condition::all()
                        .add(Expr::col("low_version".into_identity()).eq(version))
                        .add(Expr::col("low_inclusive".into_identity()).eq(false)),
                    Version::Unbounded => {
                        Condition::all().add(Expr::col("low_version".into_identity()).is_null())
                    }
                };

                let high_cond = match high {
                    Version::Inclusive(version) => Condition::all()
                        .add(Expr::col("high_version".into_identity()).eq(version))
                        .add(Expr::col("high_inclusive".into_identity()).eq(true)),
                    Version::Exclusive(version) => Condition::all()
                        .add(Expr::col("high_version".into_identity()).eq(version))
                        .add(Expr::col("high_inclusive".into_identity()).eq(false)),
                    Version::Unbounded => {
                        Condition::all().add(Expr::col("high_version".into_identity()).is_null())
                    }
                };

                Condition::all().add(low_cond).add(high_cond)
            }
        }
    }
}

#[derive(Clone, Debug)]
pub struct AdvisoryVulnerabilityContext<'g> {
    pub advisory: AdvisoryContext<'g>,
    pub advisory_vulnerability: entity::advisory_vulnerability::Model,
}

impl<'g> From<(&AdvisoryContext<'g>, entity::advisory_vulnerability::Model)>
    for AdvisoryVulnerabilityContext<'g>
{
    fn from(
        (advisory, vulnerability): (&AdvisoryContext<'g>, entity::advisory_vulnerability::Model),
    ) -> Self {
        Self {
            advisory: advisory.clone(),
            advisory_vulnerability: vulnerability,
        }
    }
}

impl<'g> AdvisoryVulnerabilityContext<'g> {
    pub async fn vulnerability<C: ConnectionTrait>(
        &self,
        connection: &C,
    ) -> Result<Option<VulnerabilityContext>, Error> {
        Ok(
            vulnerability::Entity::find_by_id(&self.advisory_vulnerability.vulnerability_id)
                .one(connection)
                .await?
                .map(|vuln| VulnerabilityContext::new(self.advisory.graph, vuln)),
        )
    }

    /*
    pub async fn get_fixed_package_version<C: ConnectionTrait>(
        &self,
        purl: &Purl,
        connection: &C,
    ) -> Result<Option<FixedPackageVersionContext>, Error> {
        if let Some(package_version) = self.advisory.graph.get_package_version(purl, connection).await? {
            Ok(entity::fixed_package_version::Entity::find()
                .filter(
                    entity::fixed_package_version::Column::AdvisoryId.eq(self.advisory.advisory.id),
                )
                .filter(
                    entity::fixed_package_version::Column::PackageVersionId
                        .eq(package_version.package_version.id),
                )
                .one(&self.advisory.graph.connection(connection))
                .await?
                .map(|affected| FixedPackageVersionContext::new(self, affected)))
        } else {
            Ok(None)
        }
    }

    pub async fn get_not_affected_package_version<C: ConnectionTrait>(
        &self,
        purl: &Purl,
        connection: &C,
    ) -> Result<Option<NotAffectedPackageVersionContext>, Error> {
        if let Some(package_version) = self.advisory.graph.get_package_version(purl, connection).await? {
            Ok(entity::not_affected_package_version::Entity::find()
                .filter(
                    entity::not_affected_package_version::Column::AdvisoryId
                        .eq(self.advisory.advisory.id),
                )
                .filter(
                    entity::not_affected_package_version::Column::PackageVersionId
                        .eq(package_version.package_version.id),
                )
                .one(&self.advisory.graph.connection(connection))
                .await?
                .map(|not_affected_package_version| {
                    NotAffectedPackageVersionContext::new(self, not_affected_package_version)
                }))
        } else {
            Ok(None)
        }
    }

    pub async fn get_affected_package_range<C: ConnectionTrait>(
        &self,
        purl: &Purl,
        start: &str,
        end: &str,
        connection: &C,
    ) -> Result<Option<AffectedPackageVersionRangeContext>, Error> {
        if let Some(package_version_range) = self
            .advisory
            .graph
            .get_package_version_range(purl, start, end, connection)
            .await?
        {
            Ok(entity::affected_package_version_range::Entity::find()
                .filter(
                    entity::affected_package_version_range::Column::AdvisoryId
                        .eq(self.advisory.advisory.id),
                )
                .filter(
                    entity::affected_package_version_range::Column::PackageVersionRangeId
                        .eq(package_version_range.package_version_range.id),
                )
                .one(&self.advisory.graph.connection(connection))
                .await?
                .map(|affected| AffectedPackageVersionRangeContext::new(self, affected)))
        } else {
            Ok(None)
        }
    }

    pub async fn ingest_not_affected_package_version<C: ConnectionTrait>(
        &self,
        purl: &Purl,
        connection: &C,
    ) -> Result<NotAffectedPackageVersionContext, Error> {
        if let Some(found) = self.get_not_affected_package_version(purl, connection).await? {
            return Ok(found);
        }

        let package_version = self
            .advisory
            .graph
            .ingest_package_version(purl, connection)
            .await?;

        let entity = entity::not_affected_package_version::ActiveModel {
            id: Default::default(),
            advisory_id: Set(self.advisory.advisory.id),
            vulnerability_id: Set(self.advisory_vulnerability.vulnerability_id),
            package_version_id: Set(package_version.package_version.id),
        };

        Ok(NotAffectedPackageVersionContext::new(
            self,
            entity.insert(&self.advisory.graph.connection(connection)).await?,
        ))
    }

    pub async fn ingest_fixed_package_version<C: ConnectionTrait>(
        &self,
        purl: &Purl,
        connection: &C,
    ) -> Result<FixedPackageVersionContext, Error> {
        if let Some(found) = self.get_fixed_package_version(purl, connection).await? {
            return Ok(found);
        }

        let package_version = self
            .advisory
            .graph
            .ingest_package_version(purl, connection)
            .await?;

        let entity = entity::fixed_package_version::ActiveModel {
            id: Default::default(),
            advisory_id: Set(self.advisory.advisory.id),
            vulnerability_id: Set(self.advisory_vulnerability.vulnerability_id),
            package_version_id: Set(package_version.package_version.id),
        };

        Ok(FixedPackageVersionContext::new(
            self,
            entity.insert(&self.advisory.graph.connection(connection)).await?,
        ))
    }

     */

    #[instrument(skip(self, connection), ret)]
    pub async fn ingest_package_status<C: ConnectionTrait>(
        &self,
        cpe_context: Option<Cpe>,
        purl: &Purl,
        status: &str,
        info: VersionInfo,
        connection: &C,
    ) -> Result<(), Error> {
        let status = status::Entity::find()
            .filter(status::Column::Slug.eq(status))
            .one(connection)
            .await?
            .ok_or(Error::InvalidStatus(status.to_string()))?;

        let package = self.advisory.graph.ingest_package(purl, connection).await?;

        let package_status = purl_status::Entity::find()
            .filter(purl_status::Column::BasePurlId.eq(package.base_purl.id))
            .filter(purl_status::Column::AdvisoryId.eq(self.advisory.advisory.id))
            .filter(purl_status::Column::StatusId.eq(status.id))
            .left_join(version_range::Entity)
            .filter(info.clone().into_condition())
            .one(connection)
            .await?;

        if package_status.is_some() {
            return Ok(());
        }

        let version_range = info.into_active_model();

        let version_range = version_range.insert(connection).await?;

        let package_status = purl_status::ActiveModel {
            id: Default::default(),
            advisory_id: Set(self.advisory_vulnerability.advisory_id),
            vulnerability_id: Set(self.advisory_vulnerability.vulnerability_id.clone()),
            status_id: Set(status.id),
            base_purl_id: Set(package.base_purl.id),
            version_range_id: Set(version_range.id),
            context_cpe_id: NotSet,
        };

        package_status.insert(connection).await?;

        Ok(())
    }

    /*
    #[instrument(skip(self, tx), err)]
    pub async fn ingest_affected_package_range<C: ConnectionTrait>(
        &self,
        purl: &Purl,
        start: &str,
        end: &str,
        connection: &C,
    ) -> Result<AffectedPackageVersionRangeContext, Error> {
        if let Some(found) = self
            .get_affected_package_range(purl, start, end, connection)
            .await?
        {
            return Ok(found);
        }

        let package_version_range = self
            .advisory
            .graph
            .ingest_package_version_range(purl, start, end, connection)
            .await?;

        let entity = entity::affected_package_version_range::ActiveModel {
            id: Default::default(),
            advisory_id: Set(self.advisory.advisory.id),
            vulnerability_id: Set(self.advisory_vulnerability.vulnerability_id),
            package_version_range_id: Set(package_version_range.package_version_range.id),
        };

        Ok(AffectedPackageVersionRangeContext::new(
            self,
            entity.insert(&self.advisory.graph.connection(connection)).await?,
        ))
    }

     */

    pub async fn cvss3_scores<C: ConnectionTrait>(
        &self,
        connection: &C,
    ) -> Result<Vec<Cvss3Base>, Error> {
        Ok(entity::cvss3::Entity::find()
            .filter(entity::cvss3::Column::AdvisoryId.eq(self.advisory_vulnerability.advisory_id))
            .filter(
                entity::cvss3::Column::VulnerabilityId
                    .eq(self.advisory_vulnerability.vulnerability_id.clone()),
            )
            .all(connection)
            .await?
            .drain(..)
            .map(|e| e.into())
            .collect())
    }

    pub async fn get_cvss3_score<C: ConnectionTrait>(
        &self,
        minor_version: u8,
        connection: &C,
    ) -> Result<Option<Cvss3Base>, Error> {
        Ok(entity::cvss3::Entity::find()
            .filter(entity::cvss3::Column::AdvisoryId.eq(self.advisory_vulnerability.advisory_id))
            .filter(
                entity::cvss3::Column::VulnerabilityId
                    .eq(self.advisory_vulnerability.vulnerability_id.clone()),
            )
            .filter(entity::cvss3::Column::MinorVersion.eq(minor_version as i32))
            .one(connection)
            .await?
            .map(|cvss| cvss.into()))
    }

    #[instrument(skip(self, connection), err)]
    pub async fn ingest_cvss3_score<C: ConnectionTrait>(
        &self,
        cvss3: Cvss3Base,
        connection: &C,
    ) -> Result<Cvss3Base, Error> {
        if let Some(found) = self
            .get_cvss3_score(cvss3.minor_version, connection)
            .await?
        {
            return Ok(found);
        }

        let model = entity::cvss3::ActiveModel {
            advisory_id: Set(self.advisory_vulnerability.advisory_id),
            vulnerability_id: Set(self.advisory_vulnerability.vulnerability_id.clone()),
            minor_version: sea_orm::ActiveValue::Set(cvss3.minor_version as i32),
            av: Set(cvss3.av.into()),
            ac: Set(cvss3.ac.into()),
            pr: Set(cvss3.pr.into()),
            ui: Set(cvss3.ui.into()),
            s: Set(cvss3.s.into()),
            c: Set(cvss3.c.into()),
            i: Set(cvss3.i.into()),
            a: Set(cvss3.a.into()),
            score: Set(cvss3.score().roundup().value()),
            severity: Set(Severity::from(cvss3.score().roundup().severity())),
        };

        Ok(model.insert(connection).await?.into())
    }
}

#[cfg(test)]
mod test {
    use crate::graph::advisory::advisory_vulnerability::{
        Version, VersionInfo, VersionScheme, VersionSpec,
    };
    use crate::graph::Graph;
    use test_context::test_context;
    use test_log::test;
    use trustify_common::hashing::Digests;
    use trustify_test_context::TrustifyContext;

    #[test_context(TrustifyContext, skip_teardown)]
    #[test(tokio::test)]
    async fn advisory_affected_vulnerability_assertions(
        ctx: TrustifyContext,
    ) -> Result<(), anyhow::Error> {
        let system = Graph::new(ctx.db.clone());

        let advisory = system
            .ingest_advisory(
                "RHSA-GHSA-1",
                ("source", "http://db.com/rhsa-ghsa-2"),
                &Digests::digest("RHSA-GHSA-1"),
                (),
                &ctx.db,
            )
            .await?;

        let advisory_vulnerability = advisory
            .link_to_vulnerability("CVE-42", None, &ctx.db)
            .await?;

        advisory_vulnerability
            .ingest_package_status(
                None,
                &"pkg:maven/io.quarkus/quarkus-core".try_into()?,
                "affected",
                VersionInfo {
                    scheme: VersionScheme::Semver,
                    spec: VersionSpec::Range(
                        Version::Inclusive("1.0.2".to_string()),
                        Version::Exclusive("1.2.0".to_string()),
                    ),
                },
                &ctx.db,
            )
            .await?;

        advisory_vulnerability
            .ingest_package_status(
                None,
                &"pkg:maven/io.quarkus/quarkus-core".try_into()?,
                "not_affected",
                VersionInfo {
                    scheme: VersionScheme::Semver,
                    spec: VersionSpec::Exact("1.1.9".to_string()),
                },
                &ctx.db,
            )
            .await?;

        /*
        let affected = advisory_vulnerability
            .affected_assertions(Transactional::None)
            .await?;

        assert_eq!(1, affected.assertions.len());

         */

        Ok(())
    }

    #[test_context(TrustifyContext, skip_teardown)]
    #[test(tokio::test)]
    async fn advisory_not_affected_vulnerability_assertions(
        ctx: TrustifyContext,
    ) -> Result<(), anyhow::Error> {
        let system = Graph::new(ctx.db.clone());

        let advisory = system
            .ingest_advisory(
                "RHSA-GHSA-1",
                ("source", "http://db.com/rhsa-ghsa-2"),
                &Digests::digest("RHSA-GHSA-1"),
                (),
                &ctx.db,
            )
            .await?;

        let advisory_vulnerability = advisory
            .link_to_vulnerability("INTERAL-77", None, &ctx.db)
            .await?;

        advisory_vulnerability
            .ingest_package_status(
                None,
                &"pkg:maven/io.quarkus/quarkus-core".try_into()?,
                "affected",
                VersionInfo {
                    scheme: VersionScheme::Semver,
                    spec: VersionSpec::Range(
                        Version::Inclusive("1.0.2".to_string()),
                        Version::Exclusive("1.2.0".to_string()),
                    ),
                },
                &ctx.db,
            )
            .await?;

        advisory_vulnerability
            .ingest_package_status(
                None,
                &"pkg:maven/io.quarkus/quarkus-core".try_into()?,
                "not_affected",
                VersionInfo {
                    scheme: VersionScheme::Semver,
                    spec: VersionSpec::Exact("1.1.9".to_string()),
                },
                &ctx.db,
            )
            .await?;

        Ok(())
    }
}
