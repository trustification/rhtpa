use crate::graph::{error::Error, vulnerability::VulnerabilityInformation};
use sea_orm::{ActiveValue::Set, ConnectionTrait, EntityTrait};
use sea_query::OnConflict;
use std::collections::BTreeMap;
use tracing::instrument;
use trustify_common::db::chunk::EntityChunkedIter;
use trustify_entity::vulnerability;

/// Creator for batch insertion of vulnerabilities
///
/// Follows the Creator pattern used by PurlCreator, CpeCreator, etc.
/// Collects vulnerability entries and creates them in batches
#[derive(Default)]
pub struct VulnerabilityCreator {
    entries: BTreeMap<String, VulnerabilityInformation>,
}

impl VulnerabilityCreator {
    pub fn new() -> Self {
        Self::default()
    }

    /// Add a vulnerability entry to be created
    pub fn add(
        &mut self,
        identifier: impl Into<String>,
        information: impl Into<VulnerabilityInformation>,
    ) {
        let identifier = identifier.into();
        let information = information.into();

        // Merge with existing entry if present, keeping data if available
        self.entries
            .entry(identifier)
            .and_modify(|existing| {
                if information.has_data() {
                    *existing = information.clone();
                }
            })
            .or_insert(information);
    }

    /// Convert a (identifier, information) tuple to an ActiveModel
    fn entry_to_model(
        (identifier, info): (String, VulnerabilityInformation),
    ) -> vulnerability::ActiveModel {
        vulnerability::ActiveModel {
            id: Set(identifier),
            title: Set(info.title),
            reserved: Set(info.reserved),
            published: Set(info.published),
            modified: Set(info.modified),
            withdrawn: Set(info.withdrawn),
            cwes: Set(info.cwes),
            base_score: Set(info.base_score),
            base_severity: Set(info.base_severity),
        }
    }

    /// Create all collected vulnerabilities in batches
    #[instrument(skip_all, fields(num = self.entries.len()), err(level=tracing::Level::INFO))]
    pub async fn create<C>(self, connection: &C) -> Result<(), Error>
    where
        C: ConnectionTrait,
    {
        if self.entries.is_empty() {
            return Ok(());
        }

        // Separate entries into those with data (DO UPDATE) and without (DO NOTHING)
        let mut with_data = Vec::new();
        let mut without_data = Vec::new();

        for (identifier, information) in self.entries {
            if information.has_data() {
                with_data.push((identifier, information));
            } else {
                without_data.push((identifier, information));
            }
        }

        // Sort by identifier to ensure consistent lock acquisition order
        with_data.sort_by(|a, b| a.0.cmp(&b.0));
        without_data.sort_by(|a, b| a.0.cmp(&b.0));

        // Batch insert vulnerabilities with data (DO UPDATE)
        if !with_data.is_empty() {
            let models: Vec<_> = with_data.into_iter().map(Self::entry_to_model).collect();

            for batch in &models.chunked() {
                vulnerability::Entity::insert_many(batch)
                    .on_conflict(
                        OnConflict::columns([vulnerability::Column::Id])
                            .update_columns([
                                vulnerability::Column::Title,
                                vulnerability::Column::Reserved,
                                vulnerability::Column::Published,
                                vulnerability::Column::Modified,
                                vulnerability::Column::Withdrawn,
                                vulnerability::Column::Cwes,
                                vulnerability::Column::BaseScore,
                                vulnerability::Column::BaseSeverity,
                            ])
                            .to_owned(),
                    )
                    .exec_without_returning(connection)
                    .await?;
            }
        }

        // Batch insert vulnerabilities without data (DO NOTHING)
        if !without_data.is_empty() {
            let models: Vec<_> = without_data.into_iter().map(Self::entry_to_model).collect();

            for batch in &models.chunked() {
                vulnerability::Entity::insert_many(batch)
                    .on_conflict(OnConflict::new().do_nothing().to_owned())
                    .do_nothing()
                    .exec_without_returning(connection)
                    .await?;
            }
        }

        Ok(())
    }
}
